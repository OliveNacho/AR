var t,e;t=void 0,e=function(t,e){function _arrayLikeToArray(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,r=Array(e);i<e;i++)r[i]=t[i];return r}function _callSuper(t,e,i){return e=_getPrototypeOf(e),function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function _assertThisInitialized(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t)}(t,_isNativeReflectConstruct()?Reflect.construct(e,i||[],_getPrototypeOf(t).constructor):e.apply(t,i))}function _classCallCheck(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function _defineProperties(t,e){for(var i=0;i<e.length;i++){var r=e[i];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,_toPropertyKey(r.key),r)}}function _createClass(t,e,i){return e&&_defineProperties(t.prototype,e),i&&_defineProperties(t,i),Object.defineProperty(t,"prototype",{writable:!1}),t}function _createForOfIteratorHelper(t,e){var i="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!i){if(Array.isArray(t)||(i=function _unsupportedIterableToArray(t,e){if(t){if("string"==typeof t)return _arrayLikeToArray(t,e);var i={}.toString.call(t).slice(8,-1);return"Object"===i&&t.constructor&&(i=t.constructor.name),"Map"===i||"Set"===i?Array.from(t):"Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?_arrayLikeToArray(t,e):void 0}}(t))||e){i&&(t=i);var r=0,F=function(){};return{s:F,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var n,s=!0,a=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return s=t.done,t},e:function(t){a=!0,n=t},f:function(){try{s||null==i.return||i.return()}finally{if(a)throw n}}}}function _defineProperty(t,e,i){return(e=_toPropertyKey(e))in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,i){var r=function _superPropBase(t,e){for(;!{}.hasOwnProperty.call(t,e)&&null!==(t=_getPrototypeOf(t)););return t}(t,e);if(r){var n=Object.getOwnPropertyDescriptor(r,e);return n.get?n.get.call(arguments.length<3?t:i):n.value}},_get.apply(null,arguments)}function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&_setPrototypeOf(t,e)}function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}function _superPropGet(t,e,i,r){var n=_get(_getPrototypeOf(t.prototype),e,i);return 2&r&&"function"==typeof n?function(t){return n.apply(i,t)}:n}function _toPropertyKey(t){var e=function _toPrimitive(t,e){if("object"!=typeof t||!t)return t;var i=t[Symbol.toPrimitive];if(void 0!==i){var r=i.call(t,e);if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t,"string");return"symbol"==typeof e?e:e+""}var i=function(){function MeshSurfaceEmitter(t){_classCallCheck(this,MeshSurfaceEmitter),_defineProperty(this,"type","mesh_surface"),_defineProperty(this,"_triangleIndexToArea",[]),_defineProperty(this,"_geometry",void 0),_defineProperty(this,"_tempA",new e.Vector3),_defineProperty(this,"_tempB",new e.Vector3),_defineProperty(this,"_tempC",new e.Vector3),t&&(this.geometry=t)}return _createClass(MeshSurfaceEmitter,[{key:"geometry",get:function get(){return this._geometry},set:function set(t){if(this._geometry=t,void 0!==t&&"string"!=typeof t){var i=new e.Triangle;this._triangleIndexToArea.length=0;var r=0;if(t.getIndex()){var n=t.getIndex().array,s=n.length/3;this._triangleIndexToArea.push(0);for(var a=0;a<s;a++)i.setFromAttributeAndIndices(t.getAttribute("position"),n[3*a],n[3*a+1],n[3*a+2]),r+=i.getArea(),this._triangleIndexToArea.push(r);t.userData.triangleIndexToArea=this._triangleIndexToArea}}}},{key:"initialize",value:function initialize(t){var e=this._geometry;if(!e||null===e.getIndex())return t.position.set(0,0,0),void t.velocity.set(0,0,1).multiplyScalar(t.startSpeed);for(var i=this._triangleIndexToArea.length-1,r=0,n=i,s=Math.random()*this._triangleIndexToArea[i];r+1<n;){var a=Math.floor((r+n)/2);s<this._triangleIndexToArea[a]?n=a:r=a}var o=Math.random(),h=Math.random();o+h>1&&(o=1-o,h=1-h);var l=e.getIndex().array[3*r],c=e.getIndex().array[3*r+1],u=e.getIndex().array[3*r+2],d=e.getAttribute("position");this._tempA.fromBufferAttribute(d,l),this._tempB.fromBufferAttribute(d,c),this._tempC.fromBufferAttribute(d,u),this._tempB.sub(this._tempA),this._tempC.sub(this._tempA),this._tempA.addScaledVector(this._tempB,o).addScaledVector(this._tempC,h),t.position.copy(this._tempA),this._tempA.copy(this._tempB).cross(this._tempC).normalize(),t.velocity.copy(this._tempA).normalize().multiplyScalar(t.startSpeed)}},{key:"toJSON",value:function toJSON(){return{type:"mesh_surface",mesh:this._geometry?this._geometry.uuid:""}}},{key:"clone",value:function clone(){return new MeshSurfaceEmitter(this._geometry)}},{key:"update",value:function update(t,e){}}],[{key:"fromJSON",value:function fromJSON(t,e){return new MeshSurfaceEmitter(e.geometries[t.geometry])}}])}(),r={id:"three.quarks",initialize:function initialize(){},emitterShapes:[{type:"mesh_surface",params:[["geometry",["geometry"]]],constructor:i,loadJSON:i.fromJSON}],behaviors:[]},n=e.ShaderChunk;function registerShaderChunks(){n.tile_pars_vertex="\n#ifdef UV_TILE\n    attribute float uvTile;\n    uniform vec2 tileCount;\n    \n    mat3 makeTileTransform(float uvTile) {\n        float col = mod(uvTile, tileCount.x);\n        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);\n        \n        return mat3(\n          1.0 / tileCount.x, 0.0, 0.0,\n          0.0, 1.0 / tileCount.y, 0.0, \n          col / tileCount.x, row / tileCount.y, 1.0);\n    }\n#else\n    mat3 makeTileTransform(float uvTile) {\n        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",n.tile_vertex="\n#ifdef UV_TILE\n    mat3 tileTransform = makeTileTransform(floor(uvTile));\n    #ifdef TILE_BLEND\n        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));\n        vUvBlend = fract(uvTile);\n    #endif\n#else\n    mat3 tileTransform = makeTileTransform(0.0);\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\nvUv = (tileTransform *vec3( uv, 1 )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;\n#endif\n\n#endif\n#ifdef USE_MAP\n\nvMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\nvAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;\n    \n#endif\n#ifdef USE_LIGHTMAP\n\nvLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_AOMAP\n\nvAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_BUMPMAP\n\nvBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_NORMALMAP\n\nvNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\nvDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\nvEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_METALNESSMAP\n\nvMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\nvRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\nvAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\nvClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\nvClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\nvClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\nvIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\nvIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\nvSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\nvSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULARMAP\n\nvSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\nvSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\nvSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\nvTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\nvThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n\n",n.tile_pars_fragment="\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",n.tile_fragment="\n#ifdef USE_MAP\n    vec4 texelColor = texture2D( map, vUv);\n    #ifdef TILE_BLEND\n        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );\n    #endif\n    diffuseColor *= texelColor;\n#endif\n",n.soft_pars_vertex="\n#ifdef SOFT_PARTICLES\n    varying vec4 projPosition;\n    varying float linearDepth;\n#endif\n",n.soft_vertex="\n#ifdef SOFT_PARTICLES\n    projPosition = gl_Position;\n    linearDepth = -mvPosition.z;\n#endif\n",n.soft_pars_fragment="\n#ifdef SOFT_PARTICLES\n\n    uniform sampler2D depthTexture;\n    uniform vec4 projParams;\n    uniform vec2 softParams;\n\n    varying vec4 projPosition;\n    varying float linearDepth;\n\n    #define SOFT_NEAR_FADE softParams.x\n    #define SOFT_INV_FADE_DISTANCE softParams.y\n\n    #define zNear projParams.x\n    #define zFar projParams.y\n\n    float linearize_depth(float d)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n\n#endif\n",n.soft_fragment="\n#ifdef SOFT_PARTICLES\n\n    /* #ifdef LOGDEPTH\n    float distSample = linearize_depth_log(sampleDepth, near, far);\n    #else\n    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);\n    #endif */\n\n    vec2 p2 = projPosition.xy / projPosition.w;\n    \n    p2 = 0.5 * p2 + 0.5;\n\n    float readDepth = texture2D(depthTexture, p2.xy).r;\n    float viewDepth = linearize_depth(readDepth);\n\n    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));\n    \n    gl_FragColor *= softParticlesFade;\n\n    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);\n#endif\n"}const s=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let a=1234567;const o=Math.PI/180,h=180/Math.PI;function generateUUID(){const t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(s[255&t]+s[t>>8&255]+s[t>>16&255]+s[t>>24&255]+"-"+s[255&e]+s[e>>8&255]+"-"+s[e>>16&15|64]+s[e>>24&255]+"-"+s[63&i|128]+s[i>>8&255]+"-"+s[i>>16&255]+s[i>>24&255]+s[255&r]+s[r>>8&255]+s[r>>16&255]+s[r>>24&255]).toLowerCase()}function clamp(t,e,i){return Math.max(e,Math.min(i,t))}function euclideanModulo(t,e){return(t%e+e)%e}function mapLinear(t,e,i,r,n){return r+(t-e)*(n-r)/(i-e)}function inverseLerp(t,e,i){return t!==e?(i-t)/(e-t):0}function lerp(t,e,i){return(1-i)*t+i*e}function damp(t,e,i,r){return lerp(t,e,1-Math.exp(-i*r))}function pingpong(t,e=1){return e-Math.abs(euclideanModulo(t,2*e)-e)}function smoothstep(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)}function smootherstep(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)}function randInt(t,e){return t+Math.floor(Math.random()*(e-t+1))}function randFloat(t,e){return t+Math.random()*(e-t)}function randFloatSpread(t){return t*(.5-Math.random())}function seededRandom(t){void 0!==t&&(a=t);let e=a+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296}function degToRad(t){return t*o}function radToDeg(t){return t*h}function isPowerOfTwo(t){return!(t&t-1)&&0!==t}function ceilPowerOfTwo(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function floorPowerOfTwo(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function setQuaternionFromProperEuler(t,e,i,r,n){const s=Math.cos,a=Math.sin,o=s(i/2),h=a(i/2),l=s((e+r)/2),c=a((e+r)/2),u=s((e-r)/2),d=a((e-r)/2),m=s((r-e)/2),p=a((r-e)/2);switch(n){case"XYX":t.set(o*c,h*u,h*d,o*l);break;case"YZY":t.set(h*d,o*c,h*u,o*l);break;case"ZXZ":t.set(h*u,h*d,o*c,o*l);break;case"XZX":t.set(o*c,h*p,h*m,o*l);break;case"YXY":t.set(h*m,o*c,h*p,o*l);break;case"ZYZ":t.set(h*p,h*m,o*c,o*l);break;default:console.warn("../math.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}function denormalize(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function normalize(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(4294967295*t);case Uint16Array:return Math.round(65535*t);case Uint8Array:return Math.round(255*t);case Int32Array:return Math.round(2147483647*t);case Int16Array:return Math.round(32767*t);case Int8Array:return Math.round(127*t);default:throw new Error("Invalid component type.")}}const l={DEG2RAD:o,RAD2DEG:h,generateUUID:generateUUID,clamp:clamp,euclideanModulo:euclideanModulo,mapLinear:mapLinear,inverseLerp:inverseLerp,lerp:lerp,damp:damp,pingpong:pingpong,smoothstep:smoothstep,smootherstep:smootherstep,randInt:randInt,randFloat:randFloat,randFloatSpread:randFloatSpread,seededRandom:seededRandom,degToRad:degToRad,radToDeg:radToDeg,isPowerOfTwo:isPowerOfTwo,ceilPowerOfTwo:ceilPowerOfTwo,floorPowerOfTwo:floorPowerOfTwo,setQuaternionFromProperEuler:setQuaternionFromProperEuler,normalize:normalize,denormalize:denormalize};class Quaternion{constructor(t=0,e=0,i=0,r=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=i,this._w=r}static slerpFlat(t,e,i,r,n,s,a){let o=i[r+0],h=i[r+1],l=i[r+2],c=i[r+3];const u=n[s+0],d=n[s+1],m=n[s+2],p=n[s+3];if(0===a)return t[e+0]=o,t[e+1]=h,t[e+2]=l,void(t[e+3]=c);if(1===a)return t[e+0]=u,t[e+1]=d,t[e+2]=m,void(t[e+3]=p);if(c!==p||o!==u||h!==d||l!==m){let t=1-a;const e=o*u+h*d+l*m+c*p,i=e>=0?1:-1,r=1-e*e;if(r>Number.EPSILON){const n=Math.sqrt(r),s=Math.atan2(n,e*i);t=Math.sin(t*s)/n,a=Math.sin(a*s)/n}const n=a*i;if(o=o*t+u*n,h=h*t+d*n,l=l*t+m*n,c=c*t+p*n,t===1-a){const t=1/Math.sqrt(o*o+h*h+l*l+c*c);o*=t,h*=t,l*=t,c*=t}}t[e]=o,t[e+1]=h,t[e+2]=l,t[e+3]=c}static multiplyQuaternionsFlat(t,e,i,r,n,s){const a=i[r],o=i[r+1],h=i[r+2],l=i[r+3],c=n[s],u=n[s+1],d=n[s+2],m=n[s+3];return t[e]=a*m+l*c+o*d-h*u,t[e+1]=o*m+l*u+h*c-a*d,t[e+2]=h*m+l*d+a*u-o*c,t[e+3]=l*m-a*c-o*u-h*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,r){return this._x=t,this._y=e,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new Quaternion(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const i=t._x,r=t._y,n=t._z,s=t._order,a=Math.cos,o=Math.sin,h=a(i/2),l=a(r/2),c=a(n/2),u=o(i/2),d=o(r/2),m=o(n/2);switch(s){case"XYZ":this._x=u*l*c+h*d*m,this._y=h*d*c-u*l*m,this._z=h*l*m+u*d*c,this._w=h*l*c-u*d*m;break;case"YXZ":this._x=u*l*c+h*d*m,this._y=h*d*c-u*l*m,this._z=h*l*m-u*d*c,this._w=h*l*c+u*d*m;break;case"ZXY":this._x=u*l*c-h*d*m,this._y=h*d*c+u*l*m,this._z=h*l*m+u*d*c,this._w=h*l*c-u*d*m;break;case"ZYX":this._x=u*l*c-h*d*m,this._y=h*d*c+u*l*m,this._z=h*l*m-u*d*c,this._w=h*l*c+u*d*m;break;case"YZX":this._x=u*l*c+h*d*m,this._y=h*d*c+u*l*m,this._z=h*l*m-u*d*c,this._w=h*l*c-u*d*m;break;case"XZY":this._x=u*l*c-h*d*m,this._y=h*d*c-u*l*m,this._z=h*l*m+u*d*c,this._w=h*l*c+u*d*m;break;default:console.warn("../math.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!0===e&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,r=Math.sin(i);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],r=e[4],n=e[8],s=e[1],a=e[5],o=e[9],h=e[2],l=e[6],c=e[10],u=i+a+c;if(u>0){const t=.5/Math.sqrt(u+1);this._w=.25/t,this._x=(l-o)*t,this._y=(n-h)*t,this._z=(s-r)*t}else if(i>a&&i>c){const t=2*Math.sqrt(1+i-a-c);this._w=(l-o)/t,this._x=.25*t,this._y=(r+s)/t,this._z=(n+h)/t}else if(a>c){const t=2*Math.sqrt(1+a-i-c);this._w=(n-h)/t,this._x=(r+s)/t,this._y=.25*t,this._z=(o+l)/t}else{const t=2*Math.sqrt(1+c-i-a);this._w=(s-r)/t,this._x=(n+h)/t,this._y=(o+l)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(clamp(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(0===i)return this;const r=Math.min(1,e/i);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,r=t._y,n=t._z,s=t._w,a=e._x,o=e._y,h=e._z,l=e._w;return this._x=i*l+s*a+r*h-n*o,this._y=r*l+s*o+n*a-i*h,this._z=n*l+s*h+i*o-r*a,this._w=s*l-i*a-r*o-n*h,this._onChangeCallback(),this}slerp(t,e){if(0===e)return this;if(1===e)return this.copy(t);const i=this._x,r=this._y,n=this._z,s=this._w;let a=s*t._w+i*t._x+r*t._y+n*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=s,this._x=i,this._y=r,this._z=n,this;const o=1-a*a;if(o<=Number.EPSILON){const t=1-e;return this._w=t*s+e*this._w,this._x=t*i+e*this._x,this._y=t*r+e*this._y,this._z=t*n+e*this._z,this.normalize(),this}const h=Math.sqrt(o),l=Math.atan2(h,a),c=Math.sin((1-e)*l)/h,u=Math.sin(e*l)/h;return this._w=s*c+this._w*u,this._x=i*c+this._x*u,this._y=r*c+this._y*u,this._z=n*c+this._z*u,this._onChangeCallback(),this}slerpQuaternions(t,e,i){return this.copy(t).slerp(e,i)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),i=Math.random(),r=Math.sqrt(1-i),n=Math.sqrt(i);return this.set(r*Math.sin(t),r*Math.cos(t),n*Math.sin(e),n*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(t=0,e=0,i=0){this.isVector3=!0,Vector3.prototype.isVector3=!0,this.x=t,this.y=e,this.z=i}set(t,e,i){return void 0===i&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new Vector3(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(u.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(u.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,r=this.z,n=t.elements;return this.x=n[0]*e+n[3]*i+n[6]*r,this.y=n[1]*e+n[4]*i+n[7]*r,this.z=n[2]*e+n[5]*i+n[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,r=this.z,n=t.elements,s=1/(n[3]*e+n[7]*i+n[11]*r+n[15]);return this.x=(n[0]*e+n[4]*i+n[8]*r+n[12])*s,this.y=(n[1]*e+n[5]*i+n[9]*r+n[13])*s,this.z=(n[2]*e+n[6]*i+n[10]*r+n[14])*s,this}applyQuaternion(t){const e=this.x,i=this.y,r=this.z,n=t.x,s=t.y,a=t.z,o=t.w,h=2*(s*r-a*i),l=2*(a*e-n*r),c=2*(n*i-s*e);return this.x=e+o*h+s*c-a*l,this.y=i+o*l+a*h-n*c,this.z=r+o*c+n*l-s*h,this}transformDirection(t){const e=this.x,i=this.y,r=this.z,n=t.elements;return this.x=n[0]*e+n[4]*i+n[8]*r,this.y=n[1]*e+n[5]*i+n[9]*r,this.z=n[2]*e+n[6]*i+n[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,r=t.y,n=t.z,s=e.x,a=e.y,o=e.z;return this.x=r*o-n*a,this.y=n*s-i*o,this.z=i*a-r*s,this}projectOnVector(t){const e=t.lengthSq();if(0===e)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return c.copy(this).projectOnVector(t),this.sub(c)}reflect(t){return this.sub(c.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return e*e+i*i+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSphericalCoords(t,e,i){const r=Math.sin(e)*t;return this.x=r*Math.sin(i),this.y=Math.cos(e)*t,this.z=r*Math.cos(i),this}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=2*Math.random()-1,i=Math.sqrt(1-e*e);return this.x=i*Math.cos(t),this.y=e,this.z=i*Math.sin(t),this}abs(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),this.z=Math.abs(this.z),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const c=new Vector3,u=new Quaternion,d=2e3,m=2001;class Matrix4{constructor(t,e,i,r,n,s,a,o,h,l,c,u,d,m,p,f){this.isMatrix4=!0,Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==t&&this.set(t,e,i,r,n,s,a,o,h,l,c,u,d,m,p,f)}extractPosition(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)}multiplyToArray(t,e,i){return console.error("THREE.Matrix4: .multiplyToArray() has been removed."),this}setRotationFromQuaternion(t){return this.makeRotationFromQuaternion(t)}set(t,e,i,r,n,s,a,o,h,l,c,u,d,m,p,f){const y=this.elements;return y[0]=t,y[4]=e,y[8]=i,y[12]=r,y[1]=n,y[5]=s,y[9]=a,y[13]=o,y[2]=h,y[6]=l,y[10]=c,y[14]=u,y[3]=d,y[7]=m,y[11]=p,y[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Matrix4).fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,r=1/p.setFromMatrixColumn(t,0).length(),n=1/p.setFromMatrixColumn(t,1).length(),s=1/p.setFromMatrixColumn(t,2).length();return e[0]=i[0]*r,e[1]=i[1]*r,e[2]=i[2]*r,e[3]=0,e[4]=i[4]*n,e[5]=i[5]*n,e[6]=i[6]*n,e[7]=0,e[8]=i[8]*s,e[9]=i[9]*s,e[10]=i[10]*s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,i=t.x,r=t.y,n=t.z,s=Math.cos(i),a=Math.sin(i),o=Math.cos(r),h=Math.sin(r),l=Math.cos(n),c=Math.sin(n);if("XYZ"===t.order){const t=s*l,i=s*c,r=a*l,n=a*c;e[0]=o*l,e[4]=-o*c,e[8]=h,e[1]=i+r*h,e[5]=t-n*h,e[9]=-a*o,e[2]=n-t*h,e[6]=r+i*h,e[10]=s*o}else if("YXZ"===t.order){const t=o*l,i=o*c,r=h*l,n=h*c;e[0]=t+n*a,e[4]=r*a-i,e[8]=s*h,e[1]=s*c,e[5]=s*l,e[9]=-a,e[2]=i*a-r,e[6]=n+t*a,e[10]=s*o}else if("ZXY"===t.order){const t=o*l,i=o*c,r=h*l,n=h*c;e[0]=t-n*a,e[4]=-s*c,e[8]=r+i*a,e[1]=i+r*a,e[5]=s*l,e[9]=n-t*a,e[2]=-s*h,e[6]=a,e[10]=s*o}else if("ZYX"===t.order){const t=s*l,i=s*c,r=a*l,n=a*c;e[0]=o*l,e[4]=r*h-i,e[8]=t*h+n,e[1]=o*c,e[5]=n*h+t,e[9]=i*h-r,e[2]=-h,e[6]=a*o,e[10]=s*o}else if("YZX"===t.order){const t=s*o,i=s*h,r=a*o,n=a*h;e[0]=o*l,e[4]=n-t*c,e[8]=r*c+i,e[1]=c,e[5]=s*l,e[9]=-a*l,e[2]=-h*l,e[6]=i*c+r,e[10]=t-n*c}else if("XZY"===t.order){const t=s*o,i=s*h,r=a*o,n=a*h;e[0]=o*l,e[4]=-c,e[8]=h*l,e[1]=t*c+n,e[5]=s*l,e[9]=i*c-r,e[2]=r*c-i,e[6]=a*l,e[10]=n*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(y,t,v)}lookAt(t,e,i){const r=this.elements;return x.subVectors(t,e),0===x.lengthSq()&&(x.z=1),x.normalize(),g.crossVectors(i,x),0===g.lengthSq()&&(1===Math.abs(i.z)?x.x+=1e-4:x.z+=1e-4,x.normalize(),g.crossVectors(i,x)),g.normalize(),S.crossVectors(x,g),r[0]=g.x,r[4]=S.x,r[8]=x.x,r[1]=g.y,r[5]=S.y,r[9]=x.y,r[2]=g.z,r[6]=S.z,r[10]=x.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,r=e.elements,n=this.elements,s=i[0],a=i[4],o=i[8],h=i[12],l=i[1],c=i[5],u=i[9],d=i[13],m=i[2],p=i[6],f=i[10],y=i[14],v=i[3],g=i[7],S=i[11],x=i[15],_=r[0],M=r[4],w=r[8],O=r[12],b=r[1],z=r[5],P=r[9],E=r[13],C=r[2],A=r[6],T=r[10],N=r[14],B=r[3],V=r[7],U=r[11],R=r[15];return n[0]=s*_+a*b+o*C+h*B,n[4]=s*M+a*z+o*A+h*V,n[8]=s*w+a*P+o*T+h*U,n[12]=s*O+a*E+o*N+h*R,n[1]=l*_+c*b+u*C+d*B,n[5]=l*M+c*z+u*A+d*V,n[9]=l*w+c*P+u*T+d*U,n[13]=l*O+c*E+u*N+d*R,n[2]=m*_+p*b+f*C+y*B,n[6]=m*M+p*z+f*A+y*V,n[10]=m*w+p*P+f*T+y*U,n[14]=m*O+p*E+f*N+y*R,n[3]=v*_+g*b+S*C+x*B,n[7]=v*M+g*z+S*A+x*V,n[11]=v*w+g*P+S*T+x*U,n[15]=v*O+g*E+S*N+x*R,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],r=t[8],n=t[12],s=t[1],a=t[5],o=t[9],h=t[13],l=t[2],c=t[6],u=t[10],d=t[14];return t[3]*(+n*o*c-r*h*c-n*a*u+i*h*u+r*a*d-i*o*d)+t[7]*(+e*o*d-e*h*u+n*s*u-r*s*d+r*h*l-n*o*l)+t[11]*(+e*h*c-e*a*d-n*s*c+i*s*d+n*a*l-i*h*l)+t[15]*(-r*a*l-e*o*c+e*a*u+r*s*c-i*s*u+i*o*l)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],r=t[2],n=t[3],s=t[4],a=t[5],o=t[6],h=t[7],l=t[8],c=t[9],u=t[10],d=t[11],m=t[12],p=t[13],f=t[14],y=t[15],v=c*f*h-p*u*h+p*o*d-a*f*d-c*o*y+a*u*y,g=m*u*h-l*f*h-m*o*d+s*f*d+l*o*y-s*u*y,S=l*p*h-m*c*h+m*a*d-s*p*d-l*a*y+s*c*y,x=m*c*o-l*p*o-m*a*u+s*p*u+l*a*f-s*c*f,_=e*v+i*g+r*S+n*x;if(0===_)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const M=1/_;return t[0]=v*M,t[1]=(p*u*n-c*f*n-p*r*d+i*f*d+c*r*y-i*u*y)*M,t[2]=(a*f*n-p*o*n+p*r*h-i*f*h-a*r*y+i*o*y)*M,t[3]=(c*o*n-a*u*n-c*r*h+i*u*h+a*r*d-i*o*d)*M,t[4]=g*M,t[5]=(l*f*n-m*u*n+m*r*d-e*f*d-l*r*y+e*u*y)*M,t[6]=(m*o*n-s*f*n-m*r*h+e*f*h+s*r*y-e*o*y)*M,t[7]=(s*u*n-l*o*n+l*r*h-e*u*h-s*r*d+e*o*d)*M,t[8]=S*M,t[9]=(m*c*n-l*p*n-m*i*d+e*p*d+l*i*y-e*c*y)*M,t[10]=(s*p*n-m*a*n+m*i*h-e*p*h-s*i*y+e*a*y)*M,t[11]=(l*a*n-s*c*n-l*i*h+e*c*h+s*i*d-e*a*d)*M,t[12]=x*M,t[13]=(l*p*r-m*c*r+m*i*u-e*p*u-l*i*f+e*c*f)*M,t[14]=(m*a*r-s*p*r-m*i*o+e*p*o+s*i*f-e*a*f)*M,t[15]=(s*c*r-l*a*r+l*i*o-e*c*o-s*i*u+e*a*u)*M,this}scale(t){const e=this.elements,i=t.x,r=t.y,n=t.z;return e[0]*=i,e[4]*=r,e[8]*=n,e[1]*=i,e[5]*=r,e[9]*=n,e[2]*=i,e[6]*=r,e[10]*=n,e[3]*=i,e[7]*=r,e[11]*=n,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,r))}makeTranslation(t,e,i){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),r=Math.sin(e),n=1-i,s=t.x,a=t.y,o=t.z,h=n*s,l=n*a;return this.set(h*s+i,h*a-r*o,h*o+r*a,0,h*a+r*o,l*a+i,l*o-r*s,0,h*o-r*a,l*o+r*s,n*o*o+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,r,n,s){return this.set(1,i,n,0,t,1,s,0,e,r,1,0,0,0,0,1),this}compose(t,e,i){const r=this.elements,n=e._x,s=e._y,a=e._z,o=e._w,h=n+n,l=s+s,c=a+a,u=n*h,d=n*l,m=n*c,p=s*l,f=s*c,y=a*c,v=o*h,g=o*l,S=o*c,x=i.x,_=i.y,M=i.z;return r[0]=(1-(p+y))*x,r[1]=(d+S)*x,r[2]=(m-g)*x,r[3]=0,r[4]=(d-S)*_,r[5]=(1-(u+y))*_,r[6]=(f+v)*_,r[7]=0,r[8]=(m+g)*M,r[9]=(f-v)*M,r[10]=(1-(u+p))*M,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,i){const r=this.elements;let n=p.set(r[0],r[1],r[2]).length();const s=p.set(r[4],r[5],r[6]).length(),a=p.set(r[8],r[9],r[10]).length();this.determinant()<0&&(n=-n),t.x=r[12],t.y=r[13],t.z=r[14],f.copy(this);const o=1/n,h=1/s,l=1/a;return f.elements[0]*=o,f.elements[1]*=o,f.elements[2]*=o,f.elements[4]*=h,f.elements[5]*=h,f.elements[6]*=h,f.elements[8]*=l,f.elements[9]*=l,f.elements[10]*=l,e.setFromRotationMatrix(f),i.x=n,i.y=s,i.z=a,this}makePerspective(t,e,i,r,n,s,a=2e3){const o=this.elements,h=2*n/(e-t),l=2*n/(i-r),c=(e+t)/(e-t),u=(i+r)/(i-r);let p,f;if(a===d)p=-(s+n)/(s-n),f=-2*s*n/(s-n);else{if(a!==m)throw new Error("Matrix4.makePerspective(): Invalid coordinate system: "+a);p=-s/(s-n),f=-s*n/(s-n)}return o[0]=h,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=l,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=p,o[14]=f,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,i,r,n,s,a=2e3){const o=this.elements,h=1/(e-t),l=1/(i-r),c=1/(s-n),u=(e+t)*h,p=(i+r)*l;let f,y;if(a===d)f=(s+n)*c,y=-2*c;else{if(a!==m)throw new Error("../math.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);f=n*c,y=-1*c}return o[0]=2*h,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-p,o[2]=0,o[6]=0,o[10]=y,o[14]=-f,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let t=0;t<16;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}const p=new Vector3,f=new Matrix4,y=new Vector3(0,0,0),v=new Vector3(1,1,1),g=new Vector3,S=new Vector3,x=new Vector3,_=new Matrix4,M=new Quaternion;class Euler{constructor(t=0,e=0,i=0,r=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=i,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,r=this._order){return this._x=t,this._y=e,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new Euler(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const r=t.elements,n=r[0],s=r[4],a=r[8],o=r[1],h=r[5],l=r[9],c=r[2],u=r[6],d=r[10];switch(e){case"XYZ":this._y=Math.asin(clamp(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-l,d),this._z=Math.atan2(-s,n)):(this._x=Math.atan2(u,h),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,h)):(this._y=Math.atan2(-c,n),this._z=0);break;case"ZXY":this._x=Math.asin(clamp(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-c,d),this._z=Math.atan2(-s,h)):(this._y=0,this._z=Math.atan2(o,n));break;case"ZYX":this._y=Math.asin(-clamp(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,n)):(this._x=0,this._z=Math.atan2(-s,h));break;case"YZX":this._z=Math.asin(clamp(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-l,h),this._y=Math.atan2(-c,n)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-clamp(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,h),this._y=Math.atan2(a,n)):(this._x=Math.atan2(-l,d),this._y=0);break;default:console.warn("../math.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===i&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return _.makeRotationFromQuaternion(t),this.setFromRotationMatrix(_,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return M.setFromEuler(this),this.setFromQuaternion(M,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(t){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Vector2{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new Vector2(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6],this.y=r[1]*e+r[4]*i+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(0===e)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}rotateAround(t,e){const i=Math.cos(e),r=Math.sin(e),n=this.x-t.x,s=this.y-t.y;return this.x=n*i-s*r+t.x,this.y=n*r+s*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}Vector2.isVector2=!0;class Vector4{constructor(t=0,e=0,i=0,r=1){Vector4.prototype.isVector4=!0,this.x=t,this.y=e,this.z=i,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,r){return this.x=t,this.y=e,this.z=i,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new Vector4(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,r=this.z,n=this.w,s=t.elements;return this.x=s[0]*e+s[4]*i+s[8]*r+s[12]*n,this.y=s[1]*e+s[5]*i+s[9]*r+s[13]*n,this.z=s[2]*e+s[6]*i+s[10]*r+s[14]*n,this.w=s[3]*e+s[7]*i+s[11]*r+s[15]*n,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,r,n;const s=.01,a=.1,o=t.elements,h=o[0],l=o[4],c=o[8],u=o[1],d=o[5],m=o[9],p=o[2],f=o[6],y=o[10];if(Math.abs(l-u)<s&&Math.abs(c-p)<s&&Math.abs(m-f)<s){if(Math.abs(l+u)<a&&Math.abs(c+p)<a&&Math.abs(m+f)<a&&Math.abs(h+d+y-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const t=(h+1)/2,o=(d+1)/2,v=(y+1)/2,g=(l+u)/4,S=(c+p)/4,x=(m+f)/4;return t>o&&t>v?t<s?(i=0,r=.707106781,n=.707106781):(i=Math.sqrt(t),r=g/i,n=S/i):o>v?o<s?(i=.707106781,r=0,n=.707106781):(r=Math.sqrt(o),i=g/r,n=x/r):v<s?(i=.707106781,r=.707106781,n=0):(n=Math.sqrt(v),i=S/n,r=x/n),this.set(i,r,n,e),this}let v=Math.sqrt((f-m)*(f-m)+(c-p)*(c-p)+(u-l)*(u-l));return Math.abs(v)<.001&&(v=1),this.x=(f-m)/v,this.y=(c-p)/v,this.z=(u-l)/v,this.w=Math.acos((h+d+y-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Matrix3{constructor(t,e,i,r,n,s,a,o,h){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==t&&this.set(t,e,i,r,n,s,a,o,h)}set(t,e,i,r,n,s,a,o,h){const l=this.elements;return l[0]=t,l[1]=r,l[2]=a,l[3]=e,l[4]=n,l[5]=o,l[6]=i,l[7]=s,l[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,r=e.elements,n=this.elements,s=i[0],a=i[3],o=i[6],h=i[1],l=i[4],c=i[7],u=i[2],d=i[5],m=i[8],p=r[0],f=r[3],y=r[6],v=r[1],g=r[4],S=r[7],x=r[2],_=r[5],M=r[8];return n[0]=s*p+a*v+o*x,n[3]=s*f+a*g+o*_,n[6]=s*y+a*S+o*M,n[1]=h*p+l*v+c*x,n[4]=h*f+l*g+c*_,n[7]=h*y+l*S+c*M,n[2]=u*p+d*v+m*x,n[5]=u*f+d*g+m*_,n[8]=u*y+d*S+m*M,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],r=t[2],n=t[3],s=t[4],a=t[5],o=t[6],h=t[7],l=t[8];return e*s*l-e*a*h-i*n*l+i*a*o+r*n*h-r*s*o}invert(){const t=this.elements,e=t[0],i=t[1],r=t[2],n=t[3],s=t[4],a=t[5],o=t[6],h=t[7],l=t[8],c=l*s-a*h,u=a*o-l*n,d=h*n-s*o,m=e*c+i*u+r*d;if(0===m)return this.set(0,0,0,0,0,0,0,0,0);const p=1/m;return t[0]=c*p,t[1]=(r*h-l*i)*p,t[2]=(a*i-r*s)*p,t[3]=u*p,t[4]=(l*e-r*o)*p,t[5]=(r*n-a*e)*p,t[6]=d*p,t[7]=(i*o-h*e)*p,t[8]=(s*e-i*n)*p,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,r,n,s,a){const o=Math.cos(n),h=Math.sin(n);return this.set(i*o,i*h,-i*(o*s+h*a)+s+t,-r*h,r*o,-r*(-h*s+o*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply(w.makeScale(t,e)),this}rotate(t){return this.premultiply(w.makeRotation(-t)),this}translate(t,e){return this.premultiply(w.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,i,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,i=t.elements;for(let t=0;t<9;t++)if(e[t]!==i[t])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return(new Matrix3).fromArray(this.elements)}}const w=new Matrix3;var O;function getValueFromEmitterMode(e,i,r,n){let s;switch(t.EmitterMode.Random===e?i=Math.random():t.EmitterMode.Burst===e&&n.isBursting&&(i=n.burstParticleIndex/n.burstParticleCount),s=r>0?Math.floor(i/r)*r:i,e){case t.EmitterMode.Loop:s%=1;break;case t.EmitterMode.PingPong:s=Math.abs(s%2-1)}return s}t.EmitterMode=void 0,(O=t.EmitterMode||(t.EmitterMode={}))[O.Random=0]="Random",O[O.Loop=1]="Loop",O[O.PingPong=2]="PingPong",O[O.Burst=3]="Burst";class Bezier{constructor(t,e,i,r){this.p=[t,e,i,r]}genValue(t){const e=t*t,i=t*t*t,r=1-t,n=r*r,s=n*r;return this.p[0]*s+this.p[1]*n*t*3+this.p[2]*r*e*3+this.p[3]*i}derivativeCoefficients(t){const e=[];for(let i=t,r=i.length-1;r>0;r--){const t=[];for(let e=0;e<r;e++){const n=r*(i[e+1]-i[e]);t.push(n)}e.push(t),i=t}return e}getSlope(t){const e=this.derivativeCoefficients(this.p)[0],i=1-t,r=i*t*2,n=t*t;return i*i*e[0]+r*e[1]+n*e[2]}controlCurve(t,e){this.p[1]=t/3+this.p[0],this.p[2]=this.p[3]-e/3}hull(t){let e,i=this.p,r=[],n=0,s=0,a=0;const o=[];for(o[n++]=i[0],o[n++]=i[1],o[n++]=i[2],o[n++]=i[3];i.length>1;){for(r=[],s=0,a=i.length-1;s<a;s++)e=t*i[s]+(1-t)*i[s+1],o[n++]=e,r.push(e);i=r}return o}split(t){const e=this.hull(t);return{left:new Bezier(e[0],e[4],e[7],e[9]),right:new Bezier(e[9],e[8],e[6],e[3]),span:e}}clone(){return new Bezier(this.p[0],this.p[1],this.p[2],this.p[3])}toJSON(){return{p0:this.p[0],p1:this.p[1],p2:this.p[2],p3:this.p[3]}}static fromJSON(t){return new Bezier(t.p0,t.p1,t.p2,t.p3)}}const ColorToJSON=t=>({r:t.x,g:t.y,b:t.z,a:t.w}),JSONToColor=t=>new Vector4(t.r,t.g,t.b,t.a),JSONToValue=(t,e)=>{switch(e){case"Vector3":return new Vector3(t.x,t.y,t.z);case"Vector4":return new Vector4(t.x,t.y,t.z,t.w);case"Color":return new Vector3(t.r,t.g,t.b);default:return t}},ValueToJSON=(t,e)=>{switch(e){case"Vector3":return{x:t.x,y:t.y,z:t.z};case"Vector4":return{x:t.x,y:t.y,z:t.z,w:t.w};case"Color":return{r:t.x,g:t.y,b:t.z};default:return t}};class RandomColor{constructor(t,e){this.a=t,this.b=e,this.type="value"}startGen(t){}genColor(t,e){const i=Math.random();return e.copy(this.a).lerp(this.b,i)}toJSON(){return{type:"RandomColor",a:ColorToJSON(this.a),b:ColorToJSON(this.b)}}static fromJSON(t){return new RandomColor(JSONToColor(t.a),JSONToColor(t.b))}clone(){return new RandomColor(this.a.clone(),this.b.clone())}}class ColorRange{constructor(t,e){this.a=t,this.b=e,this.indexCount=-1,this.type="value"}startGen(t){this.indexCount=t.length,t.push(Math.random())}genColor(t,e){return-1===this.indexCount&&this.startGen(t),e.copy(this.a).lerp(this.b,t[this.indexCount])}toJSON(){return{type:"ColorRange",a:ColorToJSON(this.a),b:ColorToJSON(this.b)}}static fromJSON(t){return new ColorRange(JSONToColor(t.a),JSONToColor(t.b))}clone(){return new ColorRange(this.a.clone(),this.b.clone())}}class ContinuousLinearFunction{constructor(t,e){this.subType=e,this.type="function",this.keys=t}findKey(t){let e=0,i=0,r=this.keys.length-1;for(;i+1<r;)if(e=Math.floor((i+r)/2),t<this.getStartX(e))r=e-1;else{if(!(t>this.getEndX(e)))return e;i=e+1}for(let e=i;e<=r;e++)if(t>=this.getStartX(e)&&t<=this.getEndX(e))return e;return-1}getStartX(t){return this.keys[t][1]}getEndX(t){return t+1<this.keys.length?this.keys[t+1][1]:1}genValue(t,e){const i=this.findKey(e);return"Number"===this.subType?-1===i?this.keys[0][0]:i+1>=this.keys.length?this.keys[this.keys.length-1][0]:(this.keys[i+1][0]-this.keys[i][0])*((e-this.getStartX(i))/(this.getEndX(i)-this.getStartX(i)))+this.keys[i][0]:-1===i?t.copy(this.keys[0][0]):i+1>=this.keys.length?t.copy(this.keys[this.keys.length-1][0]):t.copy(this.keys[i][0]).lerp(this.keys[i+1][0],(e-this.getStartX(i))/(this.getEndX(i)-this.getStartX(i)))}toJSON(){return this.keys[0][0].constructor.name,{type:"CLinearFunction",subType:this.subType,keys:this.keys.map((([t,e])=>({value:ValueToJSON(t,this.subType),pos:e})))}}static fromJSON(t){return new ContinuousLinearFunction(t.keys.map((e=>[JSONToValue(e.value,t.subType),e.pos])),t.subType)}clone(){return"Number"===this.subType?new ContinuousLinearFunction(this.keys.map((([t,e])=>[t,e])),this.subType):new ContinuousLinearFunction(this.keys.map((([t,e])=>[t.clone(),e])),this.subType)}}const b=new Vector3;class Gradient{constructor(t=[[new Vector3(0,0,0),0],[new Vector3(1,1,1),0]],e=[[1,0],[1,1]]){this.type="function",this.color=new ContinuousLinearFunction(t,"Color"),this.alpha=new ContinuousLinearFunction(e,"Number")}genColor(t,e,i){return this.color.genValue(b,i),e.set(b.x,b.y,b.z,this.alpha.genValue(1,i))}toJSON(){return{type:"Gradient",color:this.color.toJSON(),alpha:this.alpha.toJSON()}}static fromJSON(t){if(t.functions){const e=t.functions.map((t=>[ColorRange.fromJSON(t.function).a,t.start]));return t.functions.length>0&&e.push([ColorRange.fromJSON(t.functions[t.functions.length-1].function).b,1]),new Gradient(e.map((t=>[new Vector3(t[0].x,t[0].y,t[0].z),t[1]])),e.map((t=>[t[0].w,t[1]])))}{const e=new Gradient;return e.alpha=ContinuousLinearFunction.fromJSON(t.alpha),e.color=ContinuousLinearFunction.fromJSON(t.color),e}}clone(){const t=new Gradient;return t.alpha=this.alpha.clone(),t.color=this.color.clone(),t}startGen(t){}}const z=new Vector4;class RandomColorBetweenGradient{constructor(t,e){this.indexCount=0,this.type="function",this.gradient1=t,this.gradient2=e}startGen(t){this.indexCount=t.length,t.push(Math.random())}genColor(t,e,i){return this.gradient1.genColor(t,e,i),this.gradient2.genColor(t,z,i),t&&void 0!==t[this.indexCount]?e.lerp(z,t[this.indexCount]):e.lerp(z,Math.random()),e}toJSON(){return{type:"RandomColorBetweenGradient",gradient1:this.gradient1.toJSON(),gradient2:this.gradient2.toJSON()}}static fromJSON(t){return new RandomColorBetweenGradient(Gradient.fromJSON(t.gradient1),Gradient.fromJSON(t.gradient2))}clone(){return new RandomColorBetweenGradient(this.gradient1.clone(),this.gradient2.clone())}}class ConstantColor{constructor(t){this.color=t,this.type="value"}startGen(t){}genColor(t,e){return e.copy(this.color)}toJSON(){return{type:"ConstantColor",color:ColorToJSON(this.color)}}static fromJSON(t){return new ConstantColor(JSONToColor(t.color))}clone(){return new ConstantColor(this.color.clone())}}function ColorGeneratorFromJSON(t){switch(t.type){case"ConstantColor":return ConstantColor.fromJSON(t);case"ColorRange":return ColorRange.fromJSON(t);case"RandomColor":return RandomColor.fromJSON(t);case"Gradient":return Gradient.fromJSON(t);case"RandomColorBetweenGradient":return RandomColorBetweenGradient.fromJSON(t);default:return new ConstantColor(new Vector4(1,1,1,1))}}class ConstantValue{constructor(t){this.value=t,this.type="value"}startGen(t){}genValue(t){return this.value}toJSON(){return{type:"ConstantValue",value:this.value}}static fromJSON(t){return new ConstantValue(t.value)}clone(){return new ConstantValue(this.value)}}class IntervalValue{constructor(t,e){this.a=t,this.b=e,this.indexCount=-1,this.type="value"}startGen(t){this.indexCount=t.length,t.push(Math.random())}genValue(t){return-1===this.indexCount&&this.startGen(t),l.lerp(this.a,this.b,t[this.indexCount])}toJSON(){return{type:"IntervalValue",a:this.a,b:this.b}}static fromJSON(t){return new IntervalValue(t.a,t.b)}clone(){return new IntervalValue(this.a,this.b)}}class PiecewiseFunction{constructor(){this.functions=new Array}findFunction(t){let e=0,i=0,r=this.functions.length-1;for(;i+1<r;)if(e=Math.floor((i+r)/2),t<this.getStartX(e))r=e-1;else{if(!(t>this.getEndX(e)))return e;i=e+1}for(let e=i;e<=r;e++)if(t>=this.functions[e][1]&&t<=this.getEndX(e))return e;return-1}getStartX(t){return this.functions[t][1]}setStartX(t,e){t>0&&(this.functions[t][1]=e)}getEndX(t){return t+1<this.functions.length?this.functions[t+1][1]:1}setEndX(t,e){t+1<this.functions.length&&(this.functions[t+1][1]=e)}insertFunction(t,e){const i=this.findFunction(t);this.functions.splice(i+1,0,[e,t])}removeFunction(t){return this.functions.splice(t,1)[0][0]}getFunction(t){return this.functions[t][0]}setFunction(t,e){this.functions[t][0]=e}get numOfFunctions(){return this.functions.length}}class PiecewiseBezier extends PiecewiseFunction{constructor(t=[[new Bezier(0,1/3,1/3*2,1),0]]){super(),this.type="function",this.functions=t}genValue(t,e=0){const i=this.findFunction(e);return-1===i?0:this.functions[i][0].genValue((e-this.getStartX(i))/(this.getEndX(i)-this.getStartX(i)))}toSVG(t,e){if(e<1)return"";let i=["M",0,this.functions[0][0].p[0]].join(" ");for(let r=1/e;r<=1;r+=1/e)i=[i,"L",r*t,this.genValue(void 0,r)].join(" ");return i}toJSON(){return{type:"PiecewiseBezier",functions:this.functions.map((([t,e])=>({function:t.toJSON(),start:e})))}}static fromJSON(t){return new PiecewiseBezier(t.functions.map((t=>[Bezier.fromJSON(t.function),t.start])))}clone(){return new PiecewiseBezier(this.functions.map((([t,e])=>[t.clone(),e])))}startGen(t){}}function ValueGeneratorFromJSON(t){switch(t.type){case"ConstantValue":return ConstantValue.fromJSON(t);case"IntervalValue":return IntervalValue.fromJSON(t);case"PiecewiseBezier":return PiecewiseBezier.fromJSON(t);default:return new ConstantValue(0)}}class RandomQuatGenerator{constructor(){this.indexCount=0,this.type="rotation"}startGen(t){let e,i,r,n,s,a;this.indexCount=t.length,t.push(new Quaternion);do{e=2*Math.random()-1,i=2*Math.random()-1,r=e*e+i*i}while(r>1);do{n=2*Math.random()-1,s=2*Math.random()-1,a=n*n+s*s}while(a>1);const o=Math.sqrt((1-r)/a);t[this.indexCount].set(e,i,o*n,o*s)}genValue(t,e,i,r){return-1===this.indexCount&&this.startGen(t),e.copy(t[this.indexCount]),e}toJSON(){return{type:"RandomQuat"}}static fromJSON(t){return new RandomQuatGenerator}clone(){return new RandomQuatGenerator}}class AxisAngleGenerator{constructor(t,e){this.axis=t,this.angle=e,this.type="rotation"}startGen(t){this.angle.startGen(t)}genValue(t,e,i,r){return e.setFromAxisAngle(this.axis,this.angle.genValue(t,r)*i)}toJSON(){return{type:"AxisAngle",axis:{x:this.axis.x,y:this.axis.y,z:this.axis.z},angle:this.angle.toJSON()}}static fromJSON(t){return new AxisAngleGenerator(new Vector3(t.axis.x,t.axis.y,t.axis.z),ValueGeneratorFromJSON(t.angle))}clone(){return new AxisAngleGenerator(this.axis.clone(),this.angle.clone())}}class EulerGenerator{constructor(t,e,i,r){this.angleX=t,this.angleY=e,this.angleZ=i,this.type="rotation",this.eular=new Euler(0,0,0,r)}startGen(t){this.angleX.startGen(t),this.angleY.startGen(t),this.angleZ.startGen(t)}genValue(t,e,i,r){return this.eular.set(this.angleX.genValue(t,r)*i,this.angleY.genValue(t,r)*i,this.angleZ.genValue(t,r)*i),e.setFromEuler(this.eular)}toJSON(){return{type:"Euler",angleX:this.angleX.toJSON(),angleY:this.angleY.toJSON(),angleZ:this.angleZ.toJSON(),eulerOrder:this.eular.order}}static fromJSON(t){return new EulerGenerator(ValueGeneratorFromJSON(t.angleX),ValueGeneratorFromJSON(t.angleY),ValueGeneratorFromJSON(t.angleZ),t.eulerOrder)}clone(){return new EulerGenerator(this.angleX,this.angleY,this.angleZ,this.eular.order)}}function RotationGeneratorFromJSON(t){switch(t.type){case"AxisAngle":return AxisAngleGenerator.fromJSON(t);case"Euler":return EulerGenerator.fromJSON(t);case"RandomQuat":return RandomQuatGenerator.fromJSON(t);default:return new RandomQuatGenerator}}class Vector3Function{constructor(t,e,i){this.x=t,this.y=e,this.z=i,this.type="vec3function"}startGen(t){this.x.startGen(t),this.y.startGen(t),this.z.startGen(t)}genValue(t,e,i){return e.set(this.x.genValue(t,i),this.y.genValue(t,i),this.z.genValue(t,i))}toJSON(){return{type:"Vector3Function",x:this.x.toJSON(),y:this.y.toJSON(),z:this.z.toJSON()}}static fromJSON(t){return new Vector3Function(ValueGeneratorFromJSON(t.x),ValueGeneratorFromJSON(t.y),ValueGeneratorFromJSON(t.z))}clone(){return new Vector3Function(this.x,this.y,this.z)}}function Vector3GeneratorFromJSON(t){return"Vector3Function"===t.type?Vector3Function.fromJSON(t):new Vector3Function(new ConstantValue(0),new ConstantValue(0),new ConstantValue(0))}function GeneratorFromJSON(t){switch(t.type){case"ConstantValue":case"IntervalValue":case"PiecewiseBezier":return ValueGeneratorFromJSON(t);case"AxisAngle":case"RandomQuat":case"Euler":return RotationGeneratorFromJSON(t);case"Vector3Function":return Vector3GeneratorFromJSON(t);default:return new ConstantValue(0)}}class ConeEmitter{constructor(e={}){this.type="cone",this.currentValue=0,this.radius=e.radius??10,this.arc=e.arc??2*Math.PI,this.thickness=e.thickness??1,this.angle=e.angle??Math.PI/6,this.mode=e.mode??t.EmitterMode.Random,this.spread=e.spread??0,this.speed=e.speed??new ConstantValue(1),this.memory=[]}update(e,i){t.EmitterMode.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,e.emissionState.time/e.duration)*i)}initialize(t,e){const i=getValueFromEmitterMode(this.mode,this.currentValue,this.spread,e),r=l.lerp(1-this.thickness,1,Math.random()),n=i*this.arc,s=Math.sqrt(r),a=Math.sin(n),o=Math.cos(n);t.position.x=s*o,t.position.y=s*a,t.position.z=0;const h=this.angle*s;t.velocity.set(0,0,Math.cos(h)).addScaledVector(t.position,Math.sin(h)).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius)}toJSON(){return{type:"cone",radius:this.radius,arc:this.arc,thickness:this.thickness,angle:this.angle,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new ConeEmitter({radius:t.radius,arc:t.arc,thickness:t.thickness,angle:t.angle,mode:t.mode,speed:t.speed?ValueGeneratorFromJSON(t.speed):void 0,spread:t.spread})}clone(){return new ConeEmitter({radius:this.radius,arc:this.arc,thickness:this.thickness,angle:this.angle,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class CircleEmitter{constructor(e={}){this.type="circle",this.currentValue=0,this.radius=e.radius??10,this.arc=e.arc??2*Math.PI,this.thickness=e.thickness??1,this.mode=e.mode??t.EmitterMode.Random,this.spread=e.spread??0,this.speed=e.speed??new ConstantValue(1),this.memory=[]}update(t,e){this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e}initialize(t,e){const i=getValueFromEmitterMode(this.mode,this.currentValue,this.spread,e),r=l.lerp(1-this.thickness,1,Math.random()),n=i*this.arc;t.position.x=Math.cos(n),t.position.y=Math.sin(n),t.position.z=0,t.velocity.copy(t.position).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius*r)}toJSON(){return{type:"circle",radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new CircleEmitter({radius:t.radius,arc:t.arc,thickness:t.thickness,mode:t.mode,speed:t.speed?ValueGeneratorFromJSON(t.speed):void 0,spread:t.spread})}clone(){return new CircleEmitter({radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}function randomInt(t,e){return Math.floor(Math.random()*(e-t))+t}const P=new Vector3(0,1,0),E=new Vector3(0,0,0),C=new Vector3(1,1,1),A=new Vector3(0,0,1);class DonutEmitter{constructor(e={}){this.type="donut",this.currentValue=0,this.radius=e.radius??10,this.arc=e.arc??2*Math.PI,this.thickness=e.thickness??1,this.donutRadius=e.donutRadius??.2*this.radius,this.mode=e.mode??t.EmitterMode.Random,this.spread=e.spread??0,this.speed=e.speed??new ConstantValue(1),this.memory=[],this._m1=new Matrix4}update(e,i){t.EmitterMode.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,e.emissionState.time/e.duration)*i)}initialize(t,e){const i=getValueFromEmitterMode(this.mode,this.currentValue,this.spread,e),r=Math.random(),n=l.lerp(1-this.thickness,1,Math.random()),s=i*this.arc,a=r*Math.PI*2,o=Math.sin(s),h=Math.cos(s);t.position.x=this.radius*h,t.position.y=this.radius*o,t.position.z=0,t.velocity.z=this.donutRadius*n*Math.sin(a),t.velocity.x=this.donutRadius*n*Math.cos(a)*h,t.velocity.y=this.donutRadius*n*Math.cos(a)*o,t.position.add(t.velocity),t.velocity.normalize().multiplyScalar(t.startSpeed),t.rotation instanceof Quaternion&&(this._m1.lookAt(E,t.velocity,P),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"donut",radius:this.radius,arc:this.arc,thickness:this.thickness,donutRadius:this.donutRadius,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new DonutEmitter({radius:t.radius,arc:t.arc,thickness:t.thickness,donutRadius:t.donutRadius,mode:t.mode,speed:t.speed?ValueGeneratorFromJSON(t.speed):void 0,spread:t.spread})}clone(){return new DonutEmitter({radius:this.radius,arc:this.arc,thickness:this.thickness,donutRadius:this.donutRadius,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class PointEmitter{constructor(){this.type="point",this._m1=new Matrix4}update(t,e){}initialize(t){const e=Math.random(),i=Math.random(),r=e*Math.PI*2,n=Math.acos(2*i-1),s=Math.cbrt(Math.random()),a=Math.sin(r),o=Math.cos(r),h=Math.sin(n),l=Math.cos(n);t.velocity.x=s*h*o,t.velocity.y=s*h*a,t.velocity.z=s*l,t.velocity.multiplyScalar(t.startSpeed),t.position.setScalar(0),t.rotation instanceof Quaternion&&(this._m1.lookAt(E,t.position,P),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"point"}}static fromJSON(t){return new PointEmitter}clone(){return new PointEmitter}}class SphereEmitter{constructor(e={}){this.type="sphere",this.currentValue=0,this.radius=e.radius??10,this.arc=e.arc??2*Math.PI,this.thickness=e.thickness??1,this.mode=e.mode??t.EmitterMode.Random,this.spread=e.spread??0,this.speed=e.speed??new ConstantValue(1),this.memory=[],this._m1=new Matrix4}update(e,i){t.EmitterMode.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,e.emissionState.time/e.duration)*i)}initialize(t,e){const i=getValueFromEmitterMode(this.mode,this.currentValue,this.spread,e),r=Math.random(),n=l.lerp(1-this.thickness,1,Math.random()),s=i*this.arc,a=Math.acos(2*r-1),o=Math.sin(s),h=Math.cos(s),c=Math.sin(a),u=Math.cos(a);t.position.x=c*h,t.position.y=c*o,t.position.z=u,t.velocity.copy(t.position).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius*n),t.rotation instanceof Quaternion&&(this._m1.lookAt(E,t.position,P),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"sphere",radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new SphereEmitter({radius:t.radius,arc:t.arc,thickness:t.thickness,mode:t.mode,speed:t.speed?ValueGeneratorFromJSON(t.speed):void 0,spread:t.spread})}clone(){return new SphereEmitter({radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class HemisphereEmitter{constructor(e={}){this.type="hemisphere",this.currentValue=0,this.radius=e.radius??10,this.arc=e.arc??2*Math.PI,this.thickness=e.thickness??1,this.mode=e.mode??t.EmitterMode.Random,this.spread=e.spread??0,this.speed=e.speed??new ConstantValue(1),this.memory=[],this._m1=new Matrix4}update(e,i){t.EmitterMode.Random!=this.mode&&(this.currentValue+=this.speed.genValue(this.memory,e.emissionState.time/e.duration)*i)}initialize(t,e){const i=getValueFromEmitterMode(this.mode,this.currentValue,this.spread,e),r=Math.random(),n=l.lerp(1-this.thickness,1,Math.random()),s=i*this.arc,a=Math.acos(r),o=Math.sin(s),h=Math.cos(s),c=Math.sin(a),u=Math.cos(a);t.position.x=c*h,t.position.y=c*o,t.position.z=u,t.velocity.copy(t.position).multiplyScalar(t.startSpeed),t.position.multiplyScalar(this.radius*n),t.rotation instanceof Quaternion&&(this._m1.lookAt(E,t.position,P),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"hemisphere",radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new HemisphereEmitter({radius:t.radius,arc:t.arc,thickness:t.thickness,mode:t.mode,speed:t.speed?ValueGeneratorFromJSON(t.speed):void 0,spread:t.spread})}clone(){return new HemisphereEmitter({radius:this.radius,arc:this.arc,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}class GridEmitter{constructor(t={}){this.type="grid",this.width=t.width??1,this.height=t.height??1,this.column=t.column??10,this.row=t.row??10}initialize(t){const e=Math.floor(Math.random()*this.row),i=Math.floor(Math.random()*this.column);t.position.x=i*this.width/this.column-this.width/2,t.position.y=e*this.height/this.row-this.height/2,t.position.z=0,t.velocity.set(0,0,t.startSpeed)}toJSON(){return{type:"grid",width:this.width,height:this.height,column:this.column,row:this.row}}static fromJSON(t){return new GridEmitter(t)}clone(){return new GridEmitter({width:this.width,height:this.height,column:this.column,row:this.row})}update(t,e){}}class RectangleEmitter{constructor(e={}){this.type="rectangle",this.currentValue=0,this.width=e.width??10,this.height=e.height??10,this.thickness=e.thickness??1,this.mode=e.mode??t.EmitterMode.Random,this.spread=e.spread??0,this.speed=e.speed??new ConstantValue(1),this.memory=[],this._m1=new Matrix4}update(t,e){this.currentValue+=this.speed.genValue(this.memory,t.emissionState.time/t.duration)*e}initialize(t,e){const i=getValueFromEmitterMode(this.mode,this.currentValue,this.spread,e)*(2*(this.width+this.height));let r,n;i<this.width?(r=i-this.width/2,n=-this.height/2):i<this.width+this.height?(r=this.width/2,n=i-this.width-this.height/2):i<2*this.width+this.height?(r=this.width/2-(i-this.width-this.height),n=this.height/2):(r=-this.width/2,n=this.height/2-(i-2*this.width-this.height));const s=Math.random(),a=1-this.thickness*s;t.position.x=r*a,t.position.y=n*a,t.position.z=0,t.velocity.x=r,t.velocity.y=n,t.velocity.z=0,t.velocity.normalize().multiplyScalar(t.startSpeed),t.rotation instanceof Quaternion&&(this._m1.lookAt(E,t.velocity,P),t.rotation.setFromRotationMatrix(this._m1))}toJSON(){return{type:"rectangle",width:this.width,height:this.height,thickness:this.thickness,mode:this.mode,spread:this.spread,speed:this.speed.toJSON()}}static fromJSON(t){return new RectangleEmitter({width:t.width,height:t.height,thickness:t.thickness,mode:t.mode,speed:t.speed?ValueGeneratorFromJSON(t.speed):void 0,spread:t.spread})}clone(){return new RectangleEmitter({width:this.width,height:this.height,thickness:this.thickness,mode:this.mode,speed:this.speed.clone(),spread:this.spread})}}const T={circle:{type:"circle",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:CircleEmitter,loadJSON:CircleEmitter.fromJSON},cone:{type:"cone",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["angle",["radian"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:ConeEmitter,loadJSON:ConeEmitter.fromJSON},donut:{type:"donut",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["donutRadius",["number"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:DonutEmitter,loadJSON:DonutEmitter.fromJSON},point:{type:"point",params:[],constructor:PointEmitter,loadJSON:PointEmitter.fromJSON},sphere:{type:"sphere",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["angle",["radian"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:SphereEmitter,loadJSON:SphereEmitter.fromJSON},hemisphere:{type:"hemisphere",params:[["radius",["number"]],["arc",["radian"]],["thickness",["number"]],["angle",["radian"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:HemisphereEmitter,loadJSON:HemisphereEmitter.fromJSON},grid:{type:"grid",params:[["width",["number"]],["height",["number"]],["rows",["number"]],["column",["number"]]],constructor:GridEmitter,loadJSON:GridEmitter.fromJSON},rectangle:{type:"rectangle",params:[["width",["number"]],["height",["number"]],["thickness",["number"]],["mode",["emitterMode"]],["spread",["number"]],["speed",["valueFunc","value"]]],constructor:RectangleEmitter,loadJSON:RectangleEmitter.fromJSON}};function EmitterFromJSON(t,e){return T[t.type].loadJSON(t,e)}class ColorOverLife{constructor(t){this.color=t,this.type="ColorOverLife"}initialize(t){this.color.startGen(t.memory)}update(t,e){this.color.genColor(t.memory,t.color,t.age/t.life),t.color.x*=t.startColor.x,t.color.y*=t.startColor.y,t.color.z*=t.startColor.z,t.color.w*=t.startColor.w}frameUpdate(t){}toJSON(){return{type:this.type,color:this.color.toJSON()}}static fromJSON(t){return new ColorOverLife(ColorGeneratorFromJSON(t.color))}clone(){return new ColorOverLife(this.color.clone())}reset(){}}class RotationOverLife{constructor(t){this.angularVelocity=t,this.type="RotationOverLife"}initialize(t){"number"==typeof t.rotation&&this.angularVelocity.startGen(t.memory)}update(t,e){"number"==typeof t.rotation&&(t.rotation+=e*this.angularVelocity.genValue(t.memory,t.age/t.life))}toJSON(){return{type:this.type,angularVelocity:this.angularVelocity.toJSON()}}static fromJSON(t){return new RotationOverLife(ValueGeneratorFromJSON(t.angularVelocity))}frameUpdate(t){}clone(){return new RotationOverLife(this.angularVelocity.clone())}reset(){}}class Rotation3DOverLife{constructor(t){this.angularVelocity=t,this.type="Rotation3DOverLife",this.tempQuat=new Quaternion,this.tempQuat2=new Quaternion}initialize(t){t.rotation instanceof Quaternion&&(t.angularVelocity=new Quaternion,this.angularVelocity.startGen(t.memory))}update(t,e){t.rotation instanceof Quaternion&&(this.angularVelocity.genValue(t.memory,this.tempQuat,e,t.age/t.life),t.rotation.multiply(this.tempQuat))}toJSON(){return{type:this.type,angularVelocity:this.angularVelocity.toJSON()}}static fromJSON(t){return new Rotation3DOverLife(RotationGeneratorFromJSON(t.angularVelocity))}frameUpdate(t){}clone(){return new Rotation3DOverLife(this.angularVelocity.clone())}reset(){}}class ForceOverLife{initialize(t,e){this.ps=e,this.x.startGen(t.memory),this.y.startGen(t.memory),this.z.startGen(t.memory)}constructor(t,e,i){this.x=t,this.y=e,this.z=i,this.type="ForceOverLife",this._temp=new Vector3,this._tempScale=new Vector3,this._tempQ=new Quaternion}update(t,e){this._temp.set(this.x.genValue(t.memory,t.age/t.life),this.y.genValue(t.memory,t.age/t.life),this.z.genValue(t.memory,t.age/t.life)),this.ps.worldSpace||this._temp.multiply(this._tempScale).applyQuaternion(this._tempQ),t.velocity.addScaledVector(this._temp,e)}toJSON(){return{type:this.type,x:this.x.toJSON(),y:this.y.toJSON(),z:this.z.toJSON()}}static fromJSON(t){return new ForceOverLife(ValueGeneratorFromJSON(t.x),ValueGeneratorFromJSON(t.y),ValueGeneratorFromJSON(t.z))}frameUpdate(t){if(this.ps&&!this.ps.worldSpace){const t=this._temp,e=this._tempQ,i=this._tempScale;this.ps.emitter.matrixWorld.decompose(t,e,i),e.invert(),i.set(1/i.x,1/i.y,1/i.z)}}clone(){return new ForceOverLife(this.x.clone(),this.y.clone(),this.z.clone())}reset(){}}class SizeOverLife{initialize(t){this.size.startGen(t.memory)}constructor(t){this.size=t,this.type="SizeOverLife"}update(t){this.size instanceof Vector3Function?this.size.genValue(t.memory,t.size,t.age/t.life).multiply(t.startSize):t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory,t.age/t.life))}toJSON(){return{type:this.type,size:this.size.toJSON()}}static fromJSON(t){return new SizeOverLife(GeneratorFromJSON(t.size))}frameUpdate(t){}clone(){return new SizeOverLife(this.size.clone())}reset(){}}class SpeedOverLife{initialize(t){this.speed.startGen(t.memory)}constructor(t){this.speed=t,this.type="SpeedOverLife"}update(t){t.speedModifier=this.speed.genValue(t.memory,t.age/t.life)}toJSON(){return{type:this.type,speed:this.speed.toJSON()}}static fromJSON(t){return new SpeedOverLife(ValueGeneratorFromJSON(t.speed))}frameUpdate(t){}clone(){return new SpeedOverLife(this.speed.clone())}reset(){}}class FrameOverLife{constructor(t){this.frame=t,this.type="FrameOverLife"}initialize(t){this.frame.startGen(t.memory)}update(t,e){this.frame instanceof PiecewiseBezier&&(t.uvTile=this.frame.genValue(t.memory,t.age/t.life))}frameUpdate(t){}toJSON(){return{type:this.type,frame:this.frame.toJSON()}}static fromJSON(t){return new FrameOverLife(ValueGeneratorFromJSON(t.frame))}clone(){return new FrameOverLife(this.frame.clone())}reset(){}}class OrbitOverLife{constructor(t,e=new Vector3(0,1,0)){this.orbitSpeed=t,this.axis=e,this.type="OrbitOverLife",this.temp=new Vector3,this.rotation=new Quaternion}initialize(t){this.orbitSpeed.startGen(t.memory)}update(t,e){this.temp.copy(t.position).projectOnVector(this.axis),this.rotation.setFromAxisAngle(this.axis,this.orbitSpeed.genValue(t.memory,t.age/t.life)*e),t.position.sub(this.temp),t.position.applyQuaternion(this.rotation),t.position.add(this.temp)}frameUpdate(t){}toJSON(){return{type:this.type,orbitSpeed:this.orbitSpeed.toJSON(),axis:[this.axis.x,this.axis.y,this.axis.z]}}static fromJSON(t){return new OrbitOverLife(ValueGeneratorFromJSON(t.orbitSpeed),t.axis?new Vector3(t.axis[0],t.axis[1],t.axis[2]):void 0)}clone(){return new OrbitOverLife(this.orbitSpeed.clone())}reset(){}}class LinkedListNode{constructor(t){this.data=t,this.next=null,this.prev=null}hasPrev(){return null!==this.prev}hasNext(){return null!==this.next}}class LinkedList{constructor(){this.length=0,this.head=this.tail=null}isEmpty(){return null===this.head}clear(){this.length=0,this.head=this.tail=null}front(){return null===this.head?null:this.head.data}back(){return null===this.tail?null:this.tail.data}dequeue(){if(this.head){const t=this.head.data;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,t}}pop(){if(this.tail){const t=this.tail.data;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,t}}queue(t){const e=new LinkedListNode(t);this.tail||(this.tail=e),this.head&&(this.head.prev=e,e.next=this.head),this.head=e,this.length++}push(t){const e=new LinkedListNode(t);this.head||(this.head=e),this.tail&&(this.tail.next=e,e.prev=this.tail),this.tail=e,this.length++}insertBefore(t,e){const i=new LinkedListNode(e);i.next=t,i.prev=t.prev,null!==i.prev&&(i.prev.next=i),i.next.prev=i,t==this.head&&(this.head=i),this.length++}remove(t){if(null===this.head||null===this.tail)return;let e=this.head;for(t===this.head.data&&(this.head=this.head.next),t===this.tail.data&&(this.tail=this.tail.prev);null!==e.next&&e.data!==t;)e=e.next;e.data===t&&(null!==e.prev&&(e.prev.next=e.next),null!==e.next&&(e.next.prev=e.prev),this.length--)}*values(){let t=this.head;for(;null!==t;)yield t.data,t=t.next}}class SpriteParticle{constructor(){this.startSpeed=0,this.startColor=new Vector4,this.startSize=new Vector3(1,1,1),this.position=new Vector3,this.velocity=new Vector3,this.age=0,this.life=1,this.size=new Vector3(1,1,1),this.speedModifier=1,this.rotation=0,this.color=new Vector4,this.uvTile=0,this.memory=[]}get died(){return this.age>=this.life}reset(){this.memory.length=0}}class RecordState{constructor(t,e,i){this.position=t,this.size=e,this.color=i}}class TrailParticle{constructor(){this.startSpeed=0,this.startColor=new Vector4,this.startSize=new Vector3(1,1,1),this.position=new Vector3,this.velocity=new Vector3,this.age=0,this.life=1,this.size=new Vector3(1,1,1),this.length=100,this.speedModifier=1,this.color=new Vector4,this.previous=new LinkedList,this.uvTile=0,this.memory=[]}update(){for(this.age<=this.life?this.previous.push(new RecordState(this.position.clone(),this.size.x,this.color.clone())):this.previous.length>0&&this.previous.dequeue();this.previous.length>this.length;)this.previous.dequeue()}get died(){return this.age>=this.life}reset(){this.memory.length=0,this.previous.clear()}}class WidthOverLength{initialize(t){this.width.startGen(t.memory)}constructor(t){this.width=t,this.type="WidthOverLength"}update(t){if(t instanceof TrailParticle){const e=t.previous.values();for(let i=0;i<t.previous.length;i++)e.next().value.size=this.width.genValue(t.memory,(t.previous.length-i)/t.length)}}frameUpdate(t){}toJSON(){return{type:this.type,width:this.width.toJSON()}}static fromJSON(t){return new WidthOverLength(ValueGeneratorFromJSON(t.width))}clone(){return new WidthOverLength(this.width.clone())}reset(){}}class ApplyForce{constructor(t,e){this.direction=t,this.magnitude=e,this.type="ApplyForce",this.memory={data:[],dataCount:0},this.magnitudeValue=this.magnitude.genValue(this.memory)}initialize(t){}update(t,e){t.velocity.addScaledVector(this.direction,this.magnitudeValue*e)}frameUpdate(t){this.magnitudeValue=this.magnitude.genValue(this.memory)}toJSON(){return{type:this.type,direction:[this.direction.x,this.direction.y,this.direction.z],magnitude:this.magnitude.toJSON()}}static fromJSON(t){return new ApplyForce(new Vector3(t.direction[0],t.direction[1],t.direction[2]),ValueGeneratorFromJSON(t.magnitude??t.force))}clone(){return new ApplyForce(this.direction.clone(),this.magnitude.clone())}reset(){}}class GravityForce{constructor(t,e){this.center=t,this.magnitude=e,this.type="GravityForce",this.temp=new Vector3}initialize(t){}update(t,e){this.temp.copy(this.center).sub(t.position).normalize(),t.velocity.addScaledVector(this.temp,this.magnitude/t.position.distanceToSquared(this.center)*e)}frameUpdate(t){}toJSON(){return{type:this.type,center:[this.center.x,this.center.y,this.center.z],magnitude:this.magnitude}}static fromJSON(t){return new GravityForce(new Vector3(t.center[0],t.center[1],t.center[2]),t.magnitude)}clone(){return new GravityForce(this.center.clone(),this.magnitude)}reset(){}}class ChangeEmitDirection{constructor(t){this.angle=t,this.type="ChangeEmitDirection",this._temp=new Vector3,this._q=new Quaternion,this.memory={data:[],dataCount:0}}initialize(t){const e=t.velocity.length();0!=e&&(t.velocity.normalize(),0===t.velocity.x&&0===t.velocity.y?this._temp.set(0,t.velocity.z,0):this._temp.set(-t.velocity.y,t.velocity.x,0),this.angle.startGen(this.memory),this._q.setFromAxisAngle(this._temp.normalize(),this.angle.genValue(this.memory)),this._temp.copy(t.velocity),t.velocity.applyQuaternion(this._q),this._q.setFromAxisAngle(this._temp,Math.random()*Math.PI*2),t.velocity.applyQuaternion(this._q),t.velocity.setLength(e))}update(t,e){}frameUpdate(t){}toJSON(){return{type:this.type,angle:this.angle.toJSON()}}static fromJSON(t){return new ChangeEmitDirection(ValueGeneratorFromJSON(t.angle))}clone(){return new ChangeEmitDirection(this.angle)}reset(){}}var N;t.SubParticleEmitMode=void 0,(N=t.SubParticleEmitMode||(t.SubParticleEmitMode={}))[N.Death=0]="Death",N[N.Birth=1]="Birth",N[N.Frame=2]="Frame";class EmitSubParticleSystem{constructor(e,i,r,n=t.SubParticleEmitMode.Frame,s=1){this.particleSystem=e,this.useVelocityAsBasis=i,this.subParticleSystem=r,this.mode=n,this.emitProbability=s,this.type="EmitSubParticleSystem",this.q_=new Quaternion,this.v_=new Vector3,this.v2_=new Vector3,this.subEmissions=new Array,this.subParticleSystem&&this.subParticleSystem.system&&(this.subParticleSystem.system.onlyUsedByOther=!0)}initialize(t){}update(e,i){(this.mode===t.SubParticleEmitMode.Frame||this.mode===t.SubParticleEmitMode.Birth&&0===e.age||this.mode===t.SubParticleEmitMode.Death&&e.age+i>=e.life)&&this.emit(e,i)}emit(t,e){if(!this.subParticleSystem)return;if(Math.random()>this.emitProbability)return;const i=new Matrix4;this.setMatrixFromParticle(i,t),this.subEmissions.push({burstParticleCount:0,burstParticleIndex:0,isBursting:!1,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,matrix:i,travelDistance:0,particle:t})}frameUpdate(t){if(this.subParticleSystem)for(let e=0;e<this.subEmissions.length;e++)if(this.subEmissions[e].time>=this.subParticleSystem.system.duration)this.subEmissions[e]=this.subEmissions[this.subEmissions.length-1],this.subEmissions.length=this.subEmissions.length-1,e--;else{const i=this.subEmissions[e];i.particle&&i.particle.age<i.particle.life?this.setMatrixFromParticle(i.matrix,i.particle):i.particle=void 0,this.subParticleSystem.system.emit(t,i,i.matrix)}}toJSON(){return{type:this.type,subParticleSystem:this.subParticleSystem?this.subParticleSystem.uuid:"",useVelocityAsBasis:this.useVelocityAsBasis,mode:this.mode,emitProbability:this.emitProbability}}static fromJSON(t,e){return new EmitSubParticleSystem(e,t.useVelocityAsBasis,t.subParticleSystem,t.mode,t.emitProbability)}clone(){return new EmitSubParticleSystem(this.particleSystem,this.useVelocityAsBasis,this.subParticleSystem,this.mode,this.emitProbability)}reset(){}setMatrixFromParticle(t,e){let i;if(void 0===e.rotation||this.useVelocityAsBasis)if(0!==e.velocity.x||0!==e.velocity.y||1!==e.velocity.z&&0!==e.velocity.z){this.v_.copy(A).cross(e.velocity),this.v2_.copy(e.velocity).cross(this.v_);const i=this.v_.length(),r=this.v2_.length();t.set(this.v_.x/i,this.v2_.x/r,e.velocity.x,e.position.x,this.v_.y/i,this.v2_.y/r,e.velocity.y,e.position.y,this.v_.z/i,this.v2_.z/r,e.velocity.z,e.position.z,0,0,0,1)}else t.set(1,0,0,e.position.x,0,1,0,e.position.y,0,0,1,e.position.z,0,0,0,1);else e.rotation instanceof Quaternion?i=e.rotation:(this.q_.setFromAxisAngle(A,e.rotation),i=this.q_),t.compose(e.position,i,C);this.particleSystem.worldSpace||t.multiplyMatrices(this.particleSystem.emitter.matrixWorld,t)}}const B=.5*(Math.sqrt(3)-1),V=(3-Math.sqrt(3))/6,U=1/3,R=1/6,k=(Math.sqrt(5)-1)/4,L=(5-Math.sqrt(5))/20,J=new Float32Array([1,1,0,-1,1,0,1,-1,0,-1,-1,0,1,0,1,-1,0,1,1,0,-1,-1,0,-1,0,1,1,0,-1,1,0,1,-1,0,-1,-1]),I=new Float32Array([0,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,1,0,1,1,1,0,1,-1,1,0,-1,1,1,0,-1,-1,-1,0,1,1,-1,0,1,-1,-1,0,-1,1,-1,0,-1,-1,1,1,0,1,1,1,0,-1,1,-1,0,1,1,-1,0,-1,-1,1,0,1,-1,1,0,-1,-1,-1,0,1,-1,-1,0,-1,1,1,1,0,1,1,-1,0,1,-1,1,0,1,-1,-1,0,-1,1,1,0,-1,1,-1,0,-1,-1,1,0,-1,-1,-1,0]);class SimplexNoise{constructor(t=Math.random){const e="function"==typeof t?t:function alea(t){let e=0,i=0,r=0,n=1;const s=function masher(){let t=4022871197;return function(e){e=e.toString();for(let i=0;i<e.length;i++){t+=e.charCodeAt(i);let r=.02519603282416938*t;t=r>>>0,r-=t,r*=t,t=r>>>0,r-=t,t+=4294967296*r}return 2.3283064365386963e-10*(t>>>0)}}();return e=s(" "),i=s(" "),r=s(" "),e-=s(t),e<0&&(e+=1),i-=s(t),i<0&&(i+=1),r-=s(t),r<0&&(r+=1),function(){const t=2091639*e+2.3283064365386963e-10*n;return e=i,i=r,r=t-(n=0|t)}}(t);this.p=function buildPermutationTable(t){const e=new Uint8Array(256);for(let t=0;t<256;t++)e[t]=t;for(let i=0;i<255;i++){const r=i+~~(t()*(256-i)),n=e[i];e[i]=e[r],e[r]=n}return e}(e),this.perm=new Uint8Array(512),this.permMod12=new Uint8Array(512);for(let t=0;t<512;t++)this.perm[t]=this.p[255&t],this.permMod12[t]=this.perm[t]%12}noise2D(t,e){const i=this.permMod12,r=this.perm;let n=0,s=0,a=0;const o=(t+e)*B,h=Math.floor(t+o),l=Math.floor(e+o),c=(h+l)*V,u=t-(h-c),d=e-(l-c);let m,p;u>d?(m=1,p=0):(m=0,p=1);const f=u-m+V,y=d-p+V,v=u-1+2*V,g=d-1+2*V,S=255&h,x=255&l;let _=.5-u*u-d*d;if(_>=0){const t=3*i[S+r[x]];_*=_,n=_*_*(J[t]*u+J[t+1]*d)}let M=.5-f*f-y*y;if(M>=0){const t=3*i[S+m+r[x+p]];M*=M,s=M*M*(J[t]*f+J[t+1]*y)}let w=.5-v*v-g*g;if(w>=0){const t=3*i[S+1+r[x+1]];w*=w,a=w*w*(J[t]*v+J[t+1]*g)}return 70*(n+s+a)}noise3D(t,e,i){const r=this.permMod12,n=this.perm;let s,a,o,h;const l=(t+e+i)*U,c=Math.floor(t+l),u=Math.floor(e+l),d=Math.floor(i+l),m=(c+u+d)*R,p=t-(c-m),f=e-(u-m),y=i-(d-m);let v,g,S,x,_,M;p>=f?f>=y?(v=1,g=0,S=0,x=1,_=1,M=0):p>=y?(v=1,g=0,S=0,x=1,_=0,M=1):(v=0,g=0,S=1,x=1,_=0,M=1):f<y?(v=0,g=0,S=1,x=0,_=1,M=1):p<y?(v=0,g=1,S=0,x=0,_=1,M=1):(v=0,g=1,S=0,x=1,_=1,M=0);const w=p-v+R,O=f-g+R,b=y-S+R,z=p-x+2*R,P=f-_+2*R,E=y-M+2*R,C=p-1+.5,A=f-1+.5,T=y-1+.5,N=255&c,B=255&u,V=255&d;let k=.6-p*p-f*f-y*y;if(k<0)s=0;else{const t=3*r[N+n[B+n[V]]];k*=k,s=k*k*(J[t]*p+J[t+1]*f+J[t+2]*y)}let L=.6-w*w-O*O-b*b;if(L<0)a=0;else{const t=3*r[N+v+n[B+g+n[V+S]]];L*=L,a=L*L*(J[t]*w+J[t+1]*O+J[t+2]*b)}let I=.6-z*z-P*P-E*E;if(I<0)o=0;else{const t=3*r[N+x+n[B+_+n[V+M]]];I*=I,o=I*I*(J[t]*z+J[t+1]*P+J[t+2]*E)}let D=.6-C*C-A*A-T*T;if(D<0)h=0;else{const t=3*r[N+1+n[B+1+n[V+1]]];D*=D,h=D*D*(J[t]*C+J[t+1]*A+J[t+2]*T)}return 32*(s+a+o+h)}noise4D(t,e,i,r){const n=this.perm;let s,a,o,h,l;const c=(t+e+i+r)*k,u=Math.floor(t+c),d=Math.floor(e+c),m=Math.floor(i+c),p=Math.floor(r+c),f=(u+d+m+p)*L,y=t-(u-f),v=e-(d-f),g=i-(m-f),S=r-(p-f);let x=0,_=0,M=0,w=0;y>v?x++:_++,y>g?x++:M++,y>S?x++:w++,v>g?_++:M++,v>S?_++:w++,g>S?M++:w++;const O=x>=3?1:0,b=_>=3?1:0,z=M>=3?1:0,P=w>=3?1:0,E=x>=2?1:0,C=_>=2?1:0,A=M>=2?1:0,T=w>=2?1:0,N=x>=1?1:0,B=_>=1?1:0,V=M>=1?1:0,U=w>=1?1:0,R=y-O+L,J=v-b+L,D=g-z+L,G=S-P+L,q=y-E+2*L,X=v-C+2*L,Q=g-A+2*L,H=S-T+2*L,Y=y-N+3*L,j=v-B+3*L,Z=g-V+3*L,W=S-U+3*L,K=y-1+4*L,$=v-1+4*L,tt=g-1+4*L,et=S-1+4*L,it=255&u,rt=255&d,nt=255&m,st=255&p;let at=.6-y*y-v*v-g*g-S*S;if(at<0)s=0;else{const t=n[it+n[rt+n[nt+n[st]]]]%32*4;at*=at,s=at*at*(I[t]*y+I[t+1]*v+I[t+2]*g+I[t+3]*S)}let ot=.6-R*R-J*J-D*D-G*G;if(ot<0)a=0;else{const t=n[it+O+n[rt+b+n[nt+z+n[st+P]]]]%32*4;ot*=ot,a=ot*ot*(I[t]*R+I[t+1]*J+I[t+2]*D+I[t+3]*G)}let ht=.6-q*q-X*X-Q*Q-H*H;if(ht<0)o=0;else{const t=n[it+E+n[rt+C+n[nt+A+n[st+T]]]]%32*4;ht*=ht,o=ht*ht*(I[t]*q+I[t+1]*X+I[t+2]*Q+I[t+3]*H)}let lt=.6-Y*Y-j*j-Z*Z-W*W;if(lt<0)h=0;else{const t=n[it+N+n[rt+B+n[nt+V+n[st+U]]]]%32*4;lt*=lt,h=lt*lt*(I[t]*Y+I[t+1]*j+I[t+2]*Z+I[t+3]*W)}let ct=.6-K*K-$*$-tt*tt-et*et;if(ct<0)l=0;else{const t=n[it+1+n[rt+1+n[nt+1+n[st+1]]]]%32*4;ct*=ct,l=ct*ct*(I[t]*K+I[t+1]*$+I[t+2]*tt+I[t+3]*et)}return 27*(s+a+o+h+l)}}class TurbulenceField{constructor(t,e,i,r){this.scale=t,this.octaves=e,this.velocityMultiplier=i,this.timeScale=r,this.type="TurbulenceField",this.generator=new SimplexNoise,this.timeOffset=new Vector3,this.temp=new Vector3,this.temp2=new Vector3,this.timeOffset.x=Math.random()/this.scale.x*this.timeScale.x,this.timeOffset.y=Math.random()/this.scale.y*this.timeScale.y,this.timeOffset.z=Math.random()/this.scale.z*this.timeScale.z}initialize(t){}update(t,e){const i=t.position.x/this.scale.x,r=t.position.y/this.scale.y,n=t.position.z/this.scale.z;this.temp.set(0,0,0);let s=1;for(let t=0;t<this.octaves;t++)this.temp2.set(this.generator.noise4D(i*s,r*s,n*s,this.timeOffset.x*s)/s,this.generator.noise4D(i*s,r*s,n*s,this.timeOffset.y*s)/s,this.generator.noise4D(i*s,r*s,n*s,this.timeOffset.z*s)/s),this.temp.add(this.temp2),s*=2;this.temp.multiply(this.velocityMultiplier),t.velocity.addScaledVector(this.temp,e)}toJSON(){return{type:this.type,scale:[this.scale.x,this.scale.y,this.scale.z],octaves:this.octaves,velocityMultiplier:[this.velocityMultiplier.x,this.velocityMultiplier.y,this.velocityMultiplier.z],timeScale:[this.timeScale.x,this.timeScale.y,this.timeScale.z]}}frameUpdate(t){this.timeOffset.x+=t*this.timeScale.x,this.timeOffset.y+=t*this.timeScale.y,this.timeOffset.z+=t*this.timeScale.z}static fromJSON(t){return new TurbulenceField(new Vector3(t.scale[0],t.scale[1],t.scale[2]),t.octaves,new Vector3(t.velocityMultiplier[0],t.velocityMultiplier[1],t.velocityMultiplier[2]),new Vector3(t.timeScale[0],t.timeScale[1],t.timeScale[2]))}clone(){return new TurbulenceField(this.scale.clone(),this.octaves,this.velocityMultiplier.clone(),this.timeScale.clone())}reset(){}}const D=[],G=new Vector3,q=new Quaternion;class Noise{constructor(t,e,i=new ConstantValue(1),r=new ConstantValue(0)){if(this.frequency=t,this.power=e,this.positionAmount=i,this.rotationAmount=r,this.type="Noise",this.duration=0,0===D.length)for(let t=0;t<100;t++)D.push(new SimplexNoise)}initialize(t){t.lastPosNoise=new Vector3,"number"==typeof t.rotation?t.lastRotNoise=0:t.lastRotNoise=new Quaternion,t.generatorIndex=[randomInt(0,100),randomInt(0,100),randomInt(0,100),randomInt(0,100)],this.positionAmount.startGen(t.memory),this.rotationAmount.startGen(t.memory),this.frequency.startGen(t.memory),this.power.startGen(t.memory)}update(t,e){let i=this.frequency.genValue(t.memory,t.age/t.life),r=this.power.genValue(t.memory,t.age/t.life),n=this.positionAmount.genValue(t.memory,t.age/t.life),s=this.rotationAmount.genValue(t.memory,t.age/t.life);n>0&&void 0!==t.lastPosNoise&&(t.position.sub(t.lastPosNoise),G.set(D[t.generatorIndex[0]].noise2D(0,t.age*i)*r*n,D[t.generatorIndex[1]].noise2D(0,t.age*i)*r*n,D[t.generatorIndex[2]].noise2D(0,t.age*i)*r*n),t.position.add(G),t.lastPosNoise.copy(G)),s>0&&void 0!==t.lastRotNoise&&("number"==typeof t.rotation?(t.rotation-=t.lastRotNoise,t.rotation+=D[t.generatorIndex[3]].noise2D(0,t.age*i)*Math.PI*r*s):(t.lastRotNoise.invert(),t.rotation.multiply(t.lastRotNoise),q.set(D[t.generatorIndex[0]].noise2D(0,t.age*i)*r*s,D[t.generatorIndex[1]].noise2D(0,t.age*i)*r*s,D[t.generatorIndex[2]].noise2D(0,t.age*i)*r*s,D[t.generatorIndex[3]].noise2D(0,t.age*i)*r*s).normalize(),t.rotation.multiply(q),t.lastRotNoise.copy(q)))}toJSON(){return{type:this.type,frequency:this.frequency.toJSON(),power:this.power.toJSON(),positionAmount:this.positionAmount.toJSON(),rotationAmount:this.rotationAmount.toJSON()}}frameUpdate(t){this.duration+=t}static fromJSON(t){return new Noise(ValueGeneratorFromJSON(t.frequency),ValueGeneratorFromJSON(t.power),ValueGeneratorFromJSON(t.positionAmount),ValueGeneratorFromJSON(t.rotationAmount))}clone(){return new Noise(this.frequency.clone(),this.power.clone(),this.positionAmount.clone(),this.rotationAmount.clone())}reset(){}}class TextureSequencer{constructor(t=0,e=0,i=new Vector3){this.scaleX=t,this.scaleY=e,this.position=i,this.locations=[]}transform(t,e){t.x=this.locations[e%this.locations.length].x*this.scaleX+this.position.x,t.y=this.locations[e%this.locations.length].y*this.scaleY+this.position.y,t.z=this.position.z}static fromJSON(t){const e=new TextureSequencer(t.scaleX,t.scaleY,new Vector3(t.position[0],t.position[1],t.position[2]));return e.locations=t.locations.map((t=>new Vector2(t.x,t.y))),e}clone(){const t=new TextureSequencer(this.scaleX,this.scaleY,this.position.clone());return t.locations=this.locations.map((t=>t.clone())),t}toJSON(){return{scaleX:this.scaleX,scaleY:this.scaleY,position:this.position,locations:this.locations.map((t=>({x:t.x,y:t.y})))}}fromImage(t,e){const i=document.createElement("canvas");i.width=t.width,i.height=t.height;const r=i.getContext("2d");if(!r)return;r.drawImage(t,0,0);const n=r.getImageData(0,0,i.width,i.height,{colorSpace:"srgb"});i.remove(),this.locations.length=0;for(let t=0;t<n.height;t++)for(let i=0;i<n.width;i++)n.data[4*(t*n.width+i)+3]>e&&this.locations.push(new Vector2(i,n.height-t))}}function SequencerFromJSON(t){return"TextureSequencer"===t.type?TextureSequencer.fromJSON(t):new TextureSequencer}class ApplySequences{constructor(t){this.type="ApplySequences",this.sequencers=[],this.time=0,this.index=0,this.pCount=0,this.tempV=new Vector3,this.delay=t}initialize(t){t.id=this.pCount,t.dst=new Vector3,t.begin=new Vector3,t.inMotion=!1,this.pCount++}reset(){this.time=0,this.index=0,this.pCount=0}update(t,e){const i=this.sequencers[this.index],r=t.id*this.delay;this.time>=i[0].a+r&&this.time<=i[0].b+r?(t.inMotion||(t.inMotion=!0,t.begin.copy(t.position),i[1].transform(t.dst,t.id)),t.position.lerpVectors(t.begin,t.dst,ApplySequences.BEZIER.genValue((this.time-i[0].a-r)/(i[0].b-i[0].a)))):this.time>i[0].b+r&&(t.inMotion=!1)}frameUpdate(t){for(;this.index+1<this.sequencers.length&&this.time>=this.sequencers[this.index+1][0].a;)this.index++;this.time+=t}appendSequencer(t,e){this.sequencers.push([t,e])}toJSON(){return{type:this.type,delay:this.delay,sequencers:this.sequencers.map((([t,e])=>({range:t.toJSON(),sequencer:e.toJSON()})))}}static fromJSON(t){const e=new ApplySequences(t.delay);return t.sequencers.forEach((t=>{e.sequencers.push([ValueGeneratorFromJSON(t.range),SequencerFromJSON(t.sequencer)])})),e}clone(){const t=new ApplySequences(this.delay);return t.sequencers=this.sequencers.map((t=>[t[0].clone(),t[1].clone()])),t}}let X;function getPhysicsResolver(){return X}ApplySequences.BEZIER=new Bezier(0,0,1,1);class ApplyCollision{constructor(t,e){this.resolver=t,this.bounce=e,this.type="ApplyCollision",this.tempV=new Vector3}initialize(t){}update(t,e){this.resolver.resolve(t.position,this.tempV)&&t.velocity.reflect(this.tempV).multiplyScalar(this.bounce)}frameUpdate(t){}toJSON(){return{type:this.type,bounce:this.bounce}}static fromJSON(t){return new ApplyCollision(getPhysicsResolver(),t.bounce)}clone(){return new ApplyCollision(this.resolver,this.bounce)}reset(){}}class ColorBySpeed{constructor(t,e){this.color=t,this.speedRange=e,this.type="ColorBySpeed"}initialize(t){this.color.startGen(t.memory)}update(t,e){const i=(t.startSpeed-this.speedRange.a)/(this.speedRange.b-this.speedRange.a);this.color.genColor(t.memory,t.color,i),t.color.x*=t.startColor.x,t.color.y*=t.startColor.y,t.color.z*=t.startColor.z,t.color.w*=t.startColor.w}frameUpdate(t){}toJSON(){return{type:this.type,color:this.color.toJSON(),speedRange:this.speedRange.toJSON()}}static fromJSON(t){return new ColorBySpeed(ColorGeneratorFromJSON(t.color),IntervalValue.fromJSON(t.speedRange))}clone(){return new ColorBySpeed(this.color.clone(),this.speedRange.clone())}reset(){}}class SizeBySpeed{initialize(t){this.size.startGen(t.memory)}constructor(t,e){this.size=t,this.speedRange=e,this.type="SizeBySpeed"}update(t){const e=(t.startSpeed-this.speedRange.a)/(this.speedRange.b-this.speedRange.a);this.size instanceof Vector3Function?this.size.genValue(t.memory,t.size,e).multiply(t.startSize):t.size.copy(t.startSize).multiplyScalar(this.size.genValue(t.memory,e))}toJSON(){return{type:this.type,size:this.size.toJSON(),speedRange:this.speedRange.toJSON()}}static fromJSON(t){return new SizeBySpeed(GeneratorFromJSON(t.size),IntervalValue.fromJSON(t.speedRange))}frameUpdate(t){}clone(){return new SizeBySpeed(this.size.clone(),this.speedRange.clone())}reset(){}}class RotationBySpeed{constructor(t,e){this.angularVelocity=t,this.speedRange=e,this.type="RotationBySpeed",this.tempQuat=new Quaternion}initialize(t){"number"==typeof t.rotation&&this.angularVelocity.startGen(t.memory)}update(t,e){if("number"==typeof t.rotation){const i=(t.startSpeed-this.speedRange.a)/(this.speedRange.b-this.speedRange.a);t.rotation+=e*this.angularVelocity.genValue(t.memory,i)}}toJSON(){return{type:this.type,angularVelocity:this.angularVelocity.toJSON(),speedRange:this.speedRange.toJSON()}}static fromJSON(t){return new RotationBySpeed(ValueGeneratorFromJSON(t.angularVelocity),IntervalValue.fromJSON(t.speedRange))}frameUpdate(t){}clone(){return new RotationBySpeed(this.angularVelocity.clone(),this.speedRange.clone())}reset(){}}class LimitSpeedOverLife{initialize(t){this.speed.startGen(t.memory)}constructor(t,e){this.speed=t,this.dampen=e,this.type="LimitSpeedOverLife"}update(t,e){let i=t.velocity.length(),r=this.speed.genValue(t.memory,t.age/t.life);if(i>r){const n=(i-r)/i;t.velocity.multiplyScalar(1-n*this.dampen*e*20)}}toJSON(){return{type:this.type,speed:this.speed.toJSON(),dampen:this.dampen}}static fromJSON(t){return new LimitSpeedOverLife(ValueGeneratorFromJSON(t.speed),t.dampen)}frameUpdate(t){}clone(){return new LimitSpeedOverLife(this.speed.clone(),this.dampen)}reset(){}}const Q={ApplyForce:{type:"ApplyForce",constructor:ApplyForce,params:[["direction",["vec3"]],["magnitude",["value"]]],loadJSON:ApplyForce.fromJSON},Noise:{type:"Noise",constructor:Noise,params:[["frequency",["value"]],["power",["value"]],["positionAmount",["value"]],["rotationAmount",["value"]]],loadJSON:Noise.fromJSON},TurbulenceField:{type:"TurbulenceField",constructor:TurbulenceField,params:[["scale",["vec3"]],["octaves",["number"]],["velocityMultiplier",["vec3"]],["timeScale",["vec3"]]],loadJSON:TurbulenceField.fromJSON},GravityForce:{type:"GravityForce",constructor:GravityForce,params:[["center",["vec3"]],["magnitude",["number"]]],loadJSON:GravityForce.fromJSON},ColorOverLife:{type:"ColorOverLife",constructor:ColorOverLife,params:[["color",["colorFunc"]]],loadJSON:ColorOverLife.fromJSON},RotationOverLife:{type:"RotationOverLife",constructor:RotationOverLife,params:[["angularVelocity",["value","valueFunc"]]],loadJSON:RotationOverLife.fromJSON},Rotation3DOverLife:{type:"Rotation3DOverLife",constructor:Rotation3DOverLife,params:[["angularVelocity",["rotationFunc"]]],loadJSON:Rotation3DOverLife.fromJSON},SizeOverLife:{type:"SizeOverLife",constructor:SizeOverLife,params:[["size",["value","valueFunc","vec3Func"]]],loadJSON:SizeOverLife.fromJSON},ColorBySpeed:{type:"ColorBySpeed",constructor:ColorBySpeed,params:[["color",["colorFunc"]],["speedRange",["range"]]],loadJSON:ColorBySpeed.fromJSON},RotationBySpeed:{type:"RotationBySpeed",constructor:RotationBySpeed,params:[["angularVelocity",["value","valueFunc"]],["speedRange",["range"]]],loadJSON:RotationBySpeed.fromJSON},SizeBySpeed:{type:"SizeBySpeed",constructor:SizeBySpeed,params:[["size",["value","valueFunc","vec3Func"]],["speedRange",["range"]]],loadJSON:SizeBySpeed.fromJSON},SpeedOverLife:{type:"SpeedOverLife",constructor:SpeedOverLife,params:[["speed",["value","valueFunc"]]],loadJSON:SpeedOverLife.fromJSON},FrameOverLife:{type:"FrameOverLife",constructor:FrameOverLife,params:[["frame",["value","valueFunc"]]],loadJSON:FrameOverLife.fromJSON},ForceOverLife:{type:"ForceOverLife",constructor:ForceOverLife,params:[["x",["value","valueFunc"]],["y",["value","valueFunc"]],["z",["value","valueFunc"]]],loadJSON:ForceOverLife.fromJSON},OrbitOverLife:{type:"OrbitOverLife",constructor:OrbitOverLife,params:[["orbitSpeed",["value","valueFunc"]],["axis",["vec3"]]],loadJSON:OrbitOverLife.fromJSON},WidthOverLength:{type:"WidthOverLength",constructor:WidthOverLength,params:[["width",["value","valueFunc"]]],loadJSON:WidthOverLength.fromJSON},ChangeEmitDirection:{type:"ChangeEmitDirection",constructor:ChangeEmitDirection,params:[["angle",["value"]]],loadJSON:ChangeEmitDirection.fromJSON},EmitSubParticleSystem:{type:"EmitSubParticleSystem",constructor:EmitSubParticleSystem,params:[["particleSystem",["self"]],["useVelocityAsBasis",["boolean"]],["subParticleSystem",["particleSystem"]],["mode",["number"]],["emitProbability",["number"]]],loadJSON:EmitSubParticleSystem.fromJSON},LimitSpeedOverLife:{type:"LimitSpeedOverLife",constructor:LimitSpeedOverLife,params:[["speed",["value","valueFunc"]],["dampen",["number"]]],loadJSON:LimitSpeedOverLife.fromJSON}};function BehaviorFromJSON(t,e){return Q[t.type]?Q[t.type].loadJSON(t,e):null}const H=[];function loadPlugin(t){if(!H.find((e=>e.id===t.id))){t.initialize();for(const e of t.emitterShapes)T[e.type]||(T[e.type]=e);for(const e of t.behaviors)Q[e.type]||(Q[e.type]=e)}}var Y=function(t){function ParticleEmitter(t){var e;return _classCallCheck(this,ParticleEmitter),_defineProperty(e=_callSuper(this,ParticleEmitter),"type","ParticleEmitter"),_defineProperty(e,"system",void 0),e.system=t,e}return _inherits(ParticleEmitter,t),_createClass(ParticleEmitter,[{key:"clone",value:function clone(){var t=this.system.clone();return t.emitter.copy(this,!0),t.emitter}},{key:"dispose",value:function dispose(){}},{key:"extractFromCache",value:function extractFromCache(t){var e=[];for(var i in t){var r=t[i];delete r.metadata,e.push(r)}return e}},{key:"toJSON",value:function toJSON(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=this.children;this.children=this.children.filter((function(t){return"ParticleSystemPreview"!==t.type}));var r=_superPropGet(ParticleEmitter,"toJSON",this,3)([t]);return this.children=i,null!==this.system&&(r.object.ps=this.system.toJSON(t,e)),r}}])}(e.Object3D),j=function(t){return t[t.BillBoard=0]="BillBoard",t[t.StretchedBillBoard=1]="StretchedBillBoard",t[t.Mesh=2]="Mesh",t[t.Trail=3]="Trail",t[t.HorizontalBillBoard=4]="HorizontalBillBoard",t[t.VerticalBillBoard=5]="VerticalBillBoard",t}({}),Z=function(t){function VFXBatch(t){var i;_classCallCheck(this,VFXBatch),_defineProperty(i=_callSuper(this,VFXBatch),"type","VFXBatch"),_defineProperty(i,"systems",void 0),_defineProperty(i,"settings",void 0),_defineProperty(i,"maxParticles",void 0),i.maxParticles=1e3,i.systems=new Set;var r=new e.Layers;r.mask=t.layers.mask;var n=t.material.clone();return n.defines={},Object.assign(n.defines,t.material.defines),i.settings={instancingGeometry:t.instancingGeometry,renderMode:t.renderMode,renderOrder:t.renderOrder,material:n,uTileCount:t.uTileCount,vTileCount:t.vTileCount,blendTiles:t.blendTiles,softParticles:t.softParticles,softNearFade:t.softNearFade,softFarFade:t.softFarFade,layers:r},i.frustumCulled=!1,i.renderOrder=i.settings.renderOrder,i}return _inherits(VFXBatch,t),_createClass(VFXBatch,[{key:"addSystem",value:function addSystem(t){this.systems.add(t)}},{key:"removeSystem",value:function removeSystem(t){this.systems.delete(t)}},{key:"applyDepthTexture",value:function applyDepthTexture(t){var e=this.material.uniforms.depthTexture;e&&e.value!==t&&(e.value=t,this.material.needsUpdate=!0)}},{key:"getVisibleSystems",value:function getVisibleSystems(){return Array.from(this.systems).filter((function(t){return t.emitter.visible}))}}])}(e.Mesh),W=new Vector3(0,0,1),K=new Quaternion,$=new Vector3,tt=new Vector3;new Vector3;var et=new e.PlaneGeometry(1,1,1,1),it=function(){function ParticleSystem(t){var i,r,n,s,a,o,h,l,c,u,d,m,p,f,y,v,g,S,x,_,M,w,O,b,z=this;if(_classCallCheck(this,ParticleSystem),_defineProperty(this,"autoDestroy",void 0),_defineProperty(this,"prewarm",void 0),_defineProperty(this,"looping",void 0),_defineProperty(this,"duration",void 0),_defineProperty(this,"startLife",void 0),_defineProperty(this,"startSpeed",void 0),_defineProperty(this,"startRotation",void 0),_defineProperty(this,"startSize",void 0),_defineProperty(this,"startColor",void 0),_defineProperty(this,"startTileIndex",void 0),_defineProperty(this,"rendererEmitterSettings",void 0),_defineProperty(this,"emissionOverTime",void 0),_defineProperty(this,"emissionOverDistance",void 0),_defineProperty(this,"emissionBursts",void 0),_defineProperty(this,"onlyUsedByOther",void 0),_defineProperty(this,"worldSpace",void 0),_defineProperty(this,"particleNum",void 0),_defineProperty(this,"paused",void 0),_defineProperty(this,"particles",void 0),_defineProperty(this,"emitterShape",void 0),_defineProperty(this,"emitter",void 0),_defineProperty(this,"rendererSettings",void 0),_defineProperty(this,"neededToUpdateRender",void 0),_defineProperty(this,"behaviors",void 0),_defineProperty(this,"emissionState",void 0),_defineProperty(this,"prewarmed",void 0),_defineProperty(this,"emitEnded",void 0),_defineProperty(this,"markForDestroy",void 0),_defineProperty(this,"previousWorldPos",void 0),_defineProperty(this,"temp",new Vector3),_defineProperty(this,"travelDistance",0),_defineProperty(this,"normalMatrix",new Matrix3),_defineProperty(this,"memory",[]),_defineProperty(this,"listeners",{}),_defineProperty(this,"_renderer",void 0),_defineProperty(this,"firstTimeUpdate",!0),this.autoDestroy=void 0!==t.autoDestroy&&t.autoDestroy,this.duration=null!==(i=t.duration)&&void 0!==i?i:1,this.looping=void 0===t.looping||t.looping,this.prewarm=void 0!==t.prewarm&&t.prewarm,this.startLife=null!==(r=t.startLife)&&void 0!==r?r:new ConstantValue(5),this.startSpeed=null!==(n=t.startSpeed)&&void 0!==n?n:new ConstantValue(0),this.startRotation=null!==(s=t.startRotation)&&void 0!==s?s:new ConstantValue(0),this.startSize=null!==(a=t.startSize)&&void 0!==a?a:new ConstantValue(1),this.startColor=null!==(o=t.startColor)&&void 0!==o?o:new ConstantColor(new Vector4(1,1,1,1)),this.emissionOverTime=null!==(h=t.emissionOverTime)&&void 0!==h?h:new ConstantValue(10),this.emissionOverDistance=null!==(l=t.emissionOverDistance)&&void 0!==l?l:new ConstantValue(0),this.emissionBursts=null!==(c=t.emissionBursts)&&void 0!==c?c:[],this.onlyUsedByOther=null!==(u=t.onlyUsedByOther)&&void 0!==u&&u,this.emitterShape=null!==(d=t.shape)&&void 0!==d?d:new SphereEmitter,this.behaviors=null!==(m=t.behaviors)&&void 0!==m?m:new Array,this.worldSpace=null!==(p=t.worldSpace)&&void 0!==p&&p,this.rendererEmitterSettings=null!==(f=t.rendererEmitterSettings)&&void 0!==f?f:{},t.renderMode===j.StretchedBillBoard){var P,E,C=this.rendererEmitterSettings;void 0!==t.speedFactor&&(C.speedFactor=t.speedFactor),C.speedFactor=null!==(P=C.speedFactor)&&void 0!==P?P:0,C.lengthFactor=null!==(E=C.lengthFactor)&&void 0!==E?E:0}this.rendererSettings={instancingGeometry:null!==(y=t.instancingGeometry)&&void 0!==y?y:et,renderMode:null!==(v=t.renderMode)&&void 0!==v?v:j.BillBoard,renderOrder:null!==(g=t.renderOrder)&&void 0!==g?g:0,material:t.material,uTileCount:null!==(S=t.uTileCount)&&void 0!==S?S:1,vTileCount:null!==(x=t.vTileCount)&&void 0!==x?x:1,blendTiles:null!==(_=t.blendTiles)&&void 0!==_&&_,softParticles:null!==(M=t.softParticles)&&void 0!==M&&M,softNearFade:null!==(w=t.softNearFade)&&void 0!==w?w:0,softFarFade:null!==(O=t.softFarFade)&&void 0!==O?O:0,layers:null!==(b=t.layers)&&void 0!==b?b:new e.Layers},this.neededToUpdateRender=!0,this.particles=new Array,this.startTileIndex=t.startTileIndex||new ConstantValue(0),this.emitter=new Y(this),this.paused=!1,this.particleNum=0,this.emissionState={isBursting:!1,burstParticleIndex:0,burstParticleCount:0,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,travelDistance:0},this.emissionBursts.forEach((function(t){return t.count.startGen(z.memory)})),this.emissionOverDistance.startGen(this.memory),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1}return _createClass(ParticleSystem,[{key:"time",get:function get(){return this.emissionState.time},set:function set(t){this.emissionState.time=t}},{key:"layers",get:function get(){return this.rendererSettings.layers}},{key:"texture",get:function get(){return this.rendererSettings.material.map},set:function set(t){this.rendererSettings.material.map=t,this.neededToUpdateRender=!0}},{key:"material",get:function get(){return this.rendererSettings.material},set:function set(t){this.rendererSettings.material=t,this.neededToUpdateRender=!0}},{key:"uTileCount",get:function get(){return this.rendererSettings.uTileCount},set:function set(t){this.rendererSettings.uTileCount=t,this.neededToUpdateRender=!0}},{key:"vTileCount",get:function get(){return this.rendererSettings.vTileCount},set:function set(t){this.rendererSettings.vTileCount=t,this.neededToUpdateRender=!0}},{key:"blendTiles",get:function get(){return this.rendererSettings.blendTiles},set:function set(t){this.rendererSettings.blendTiles=t,this.neededToUpdateRender=!0}},{key:"softParticles",get:function get(){return this.rendererSettings.softParticles},set:function set(t){this.rendererSettings.softParticles=t,this.neededToUpdateRender=!0}},{key:"softNearFade",get:function get(){return this.rendererSettings.softNearFade},set:function set(t){this.rendererSettings.softNearFade=t,this.neededToUpdateRender=!0}},{key:"softFarFade",get:function get(){return this.rendererSettings.softFarFade},set:function set(t){this.rendererSettings.softFarFade=t,this.neededToUpdateRender=!0}},{key:"instancingGeometry",get:function get(){return this.rendererSettings.instancingGeometry},set:function set(t){this.restart(),this.particles.length=0,this.rendererSettings.instancingGeometry=t,this.neededToUpdateRender=!0}},{key:"renderMode",get:function get(){return this.rendererSettings.renderMode},set:function set(t){if(this.rendererSettings.renderMode!==t){var e=!1;switch(this.rendererSettings.renderMode===j.Trail&&(e=!0),this.rendererSettings.renderMode===j.Mesh&&(this.startRotation=new ConstantValue(0)),t){case j.Trail:this.rendererEmitterSettings={startLength:new ConstantValue(30),followLocalOrigin:!1},e=!0;break;case j.Mesh:this.rendererEmitterSettings={geometry:et},this.startRotation=new AxisAngleGenerator(new Vector3(0,1,0),new ConstantValue(0));break;case j.StretchedBillBoard:this.rendererEmitterSettings={speedFactor:0,lengthFactor:2},this.rendererSettings.instancingGeometry=et;break;case j.BillBoard:case j.VerticalBillBoard:case j.HorizontalBillBoard:this.rendererEmitterSettings={},this.rendererSettings.instancingGeometry=et}this.rendererSettings.renderMode=t,e&&(this.restart(),this.particles.length=0),this.neededToUpdateRender=!0}}},{key:"renderOrder",get:function get(){return this.rendererSettings.renderOrder},set:function set(t){this.rendererSettings.renderOrder=t,this.neededToUpdateRender=!0}},{key:"blending",get:function get(){return this.rendererSettings.material.blending},set:function set(t){this.rendererSettings.material.blending=t,this.neededToUpdateRender=!0}},{key:"pause",value:function pause(){this.paused=!0}},{key:"play",value:function play(){this.paused=!1}},{key:"stop",value:function stop(){this.restart(),this.pause()}},{key:"spawn",value:function spawn(t,e,i){K.setFromRotationMatrix(i);var r=$,n=K,s=tt;i.decompose(r,n,s);for(var a=0;a<t;a++){for(e.burstParticleIndex=a,this.particleNum++;this.particles.length<this.particleNum;)this.rendererSettings.renderMode===j.Trail?this.particles.push(new TrailParticle):this.particles.push(new SpriteParticle);var o=this.particles[this.particleNum-1];if(o.reset(),o.speedModifier=1,this.startColor.startGen(o.memory),this.startColor.genColor(o.memory,o.startColor,this.emissionState.time),o.color.copy(o.startColor),this.startSpeed.startGen(o.memory),o.startSpeed=this.startSpeed.genValue(o.memory,e.time/this.duration),this.startLife.startGen(o.memory),o.life=this.startLife.genValue(o.memory,e.time/this.duration),o.age=0,this.startSize.startGen(o.memory),"vec3function"===this.startSize.type)this.startSize.genValue(o.memory,o.startSize,e.time/this.duration);else{var h=this.startSize.genValue(o.memory,e.time/this.duration);o.startSize.set(h,h,h)}if(this.startTileIndex.startGen(o.memory),o.uvTile=this.startTileIndex.genValue(o.memory),o.size.copy(o.startSize),this.rendererSettings.renderMode===j.Mesh||this.rendererSettings.renderMode===j.BillBoard||this.rendererSettings.renderMode===j.VerticalBillBoard||this.rendererSettings.renderMode===j.HorizontalBillBoard||this.rendererSettings.renderMode===j.StretchedBillBoard){var l=o;this.startRotation.startGen(o.memory),this.rendererSettings.renderMode===j.Mesh?(l.rotation instanceof Quaternion||(l.rotation=new Quaternion),"rotation"===this.startRotation.type?this.startRotation.genValue(o.memory,l.rotation,1,e.time/this.duration):l.rotation.setFromAxisAngle(W,this.startRotation.genValue(l.memory,e.time/this.duration))):"rotation"===this.startRotation.type?l.rotation=0:l.rotation=this.startRotation.genValue(l.memory,e.time/this.duration)}else if(this.rendererSettings.renderMode===j.Trail){var c=o;this.rendererEmitterSettings.startLength.startGen(c.memory),c.length=this.rendererEmitterSettings.startLength.genValue(c.memory,e.time/this.duration)}if(this.emitterShape.initialize(o,e),this.rendererSettings.renderMode===j.Trail&&this.rendererEmitterSettings.followLocalOrigin){var u=o;u.localPosition=(new Vector3).copy(u.position)}this.worldSpace?(o.position.applyMatrix4(i),o.startSize.multiply(s).abs(),o.size.copy(o.startSize),o.velocity.multiply(s).applyMatrix3(this.normalMatrix),o.rotation&&o.rotation instanceof Quaternion&&o.rotation.multiplyQuaternions(K,o.rotation)):this.onlyUsedByOther&&(o.parentMatrix=i);for(var d=0;d<this.behaviors.length;d++)this.behaviors[d].initialize(o,this)}}},{key:"endEmit",value:function endEmit(){this.emitEnded=!0,this.autoDestroy&&(this.markForDestroy=!0),this.fire({type:"emitEnd",particleSystem:this})}},{key:"dispose",value:function dispose(){this._renderer&&this._renderer.deleteSystem(this),this.emitter.dispose(),this.emitter.parent&&this.emitter.parent.remove(this.emitter),this.fire({type:"destroy",particleSystem:this})}},{key:"restart",value:function restart(){var t=this;this.memory.length=0,this.paused=!1,this.particleNum=0,this.emissionState.isBursting=!1,this.emissionState.burstIndex=0,this.emissionState.burstWaveIndex=0,this.emissionState.time=0,this.emissionState.waitEmiting=0,this.behaviors.forEach((function(t){t.reset()})),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1,this.emissionBursts.forEach((function(e){return e.count.startGen(t.memory)})),this.emissionOverDistance.startGen(this.memory)}},{key:"update",value:function update(t){if(!this.paused){for(var e=this.emitter;e.parent;)e=e.parent;if("Scene"===e.type)if(this.firstTimeUpdate&&(this.firstTimeUpdate=!1,this.emitter.updateWorldMatrix(!0,!1)),this.emitEnded&&0===this.particleNum)this.markForDestroy&&this.emitter.parent&&this.dispose();else{if(this.looping&&this.prewarm&&!this.prewarmed){this.prewarmed=!0;for(var i=0;i<60*this.duration;i++)this.update(1/60)}t>.1&&(t=.1),this.neededToUpdateRender&&(this._renderer&&this._renderer.updateSystem(this),this.neededToUpdateRender=!1),this.onlyUsedByOther||this.emit(t,this.emissionState,this.emitter.matrixWorld),this.emitterShape.update(this,t);for(var r=0;r<this.behaviors.length;r++){this.behaviors[r].frameUpdate(t);for(var n=0;n<this.particleNum;n++)this.particles[n].died||this.behaviors[r].update(this.particles[n],t)}for(var s=0;s<this.particleNum;s++)this.rendererEmitterSettings.followLocalOrigin&&this.particles[s].localPosition?(this.particles[s].position.copy(this.particles[s].localPosition),this.particles[s].parentMatrix?this.particles[s].position.applyMatrix4(this.particles[s].parentMatrix):this.particles[s].position.applyMatrix4(this.emitter.matrixWorld)):this.particles[s].position.addScaledVector(this.particles[s].velocity,t*this.particles[s].speedModifier),this.particles[s].age+=t;if(this.rendererSettings.renderMode===j.Trail)for(var a=0;a<this.particleNum;a++)this.particles[a].update();for(var o=0;o<this.particleNum;o++){var h=this.particles[o];!h.died||h instanceof TrailParticle&&0!==h.previous.length||(this.particles[o]=this.particles[this.particleNum-1],this.particles[this.particleNum-1]=h,this.particleNum--,o--,this.fire({type:"particleDied",particleSystem:this,particle:h}))}}else this.dispose()}}},{key:"emit",value:function emit(t,e,i){e.time>this.duration&&(this.looping?(e.time-=this.duration,e.burstIndex=0,this.behaviors.forEach((function(t){t.reset()}))):this.emitEnded||this.onlyUsedByOther||this.endEmit()),this.normalMatrix.getNormalMatrix(i);var r=Math.ceil(e.waitEmiting);for(this.spawn(r,e,i),e.waitEmiting-=r;e.burstIndex<this.emissionBursts.length&&this.emissionBursts[e.burstIndex].time<=e.time;){if(Math.random()<this.emissionBursts[e.burstIndex].probability){var n=this.emissionBursts[e.burstIndex].count.genValue(this.memory,this.time);e.isBursting=!0,e.burstParticleCount=n,this.spawn(n,e,i),e.isBursting=!1}e.burstIndex++}if(!this.emitEnded&&(e.waitEmiting+=t*this.emissionOverTime.genValue(this.memory,e.time/this.duration),null!=e.previousWorldPos)){this.temp.set(i.elements[12],i.elements[13],i.elements[14]),e.travelDistance+=e.previousWorldPos.distanceTo(this.temp);var s=this.emissionOverDistance.genValue(this.memory,e.time/this.duration);if(e.travelDistance*s>0){var a=Math.floor(e.travelDistance*s);e.travelDistance-=a/s,e.waitEmiting+=a}}void 0===e.previousWorldPos&&(e.previousWorldPos=new Vector3),e.previousWorldPos.set(i.elements[12],i.elements[13],i.elements[14]),e.time+=t}},{key:"toJSON",value:function toJSON(t){var e,i,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if((void 0===t||"string"==typeof t)&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}}),t.materials[this.rendererSettings.material.uuid]=this.rendererSettings.material.toJSON(t),r.useUrlForImage&&void 0!==(null===(e=this.texture)||void 0===e?void 0:e.source)){var n=this.texture.source;t.images[n.uuid]={uuid:n.uuid,url:this.texture.image.url}}i=this.renderMode===j.Trail?{startLength:this.rendererEmitterSettings.startLength.toJSON(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===j.Mesh?{}:this.renderMode===j.StretchedBillBoard?{speedFactor:this.rendererEmitterSettings.speedFactor,lengthFactor:this.rendererEmitterSettings.lengthFactor}:{};var s=this.rendererSettings.instancingGeometry;return t.geometries&&!t.geometries[s.uuid]&&(t.geometries[s.uuid]=s.toJSON()),{version:"3.0",autoDestroy:this.autoDestroy,looping:this.looping,prewarm:this.prewarm,duration:this.duration,shape:this.emitterShape.toJSON(),startLife:this.startLife.toJSON(),startSpeed:this.startSpeed.toJSON(),startRotation:this.startRotation.toJSON(),startSize:this.startSize.toJSON(),startColor:this.startColor.toJSON(),emissionOverTime:this.emissionOverTime.toJSON(),emissionOverDistance:this.emissionOverDistance.toJSON(),emissionBursts:this.emissionBursts.map((function(t){return{time:t.time,count:t.count.toJSON(),probability:t.probability,interval:t.interval,cycle:t.cycle}})),onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry.uuid,renderOrder:this.renderOrder,renderMode:this.renderMode,rendererEmitterSettings:i,material:this.rendererSettings.material.uuid,layers:this.layers.mask,startTileIndex:this.startTileIndex.toJSON(),uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.rendererSettings.softParticles,softFarFade:this.rendererSettings.softFarFade,softNearFade:this.rendererSettings.softNearFade,behaviors:this.behaviors.map((function(t){return t.toJSON()})),worldSpace:this.worldSpace}}},{key:"addBehavior",value:function addBehavior(t){this.behaviors.push(t)}},{key:"getRendererSettings",value:function getRendererSettings(){return this.rendererSettings}},{key:"addEventListener",value:function addEventListener(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}},{key:"removeAllEventListeners",value:function removeAllEventListeners(t){this.listeners[t]&&(this.listeners[t]=[])}},{key:"removeEventListener",value:function removeEventListener(t,e){if(this.listeners[t]){var i=this.listeners[t].indexOf(e);-1!==i&&this.listeners[t].splice(i,1)}}},{key:"fire",value:function fire(t){this.listeners[t.type]&&this.listeners[t.type].forEach((function(e){return e(t)}))}},{key:"clone",value:function clone(){var t,i=[],r=_createForOfIteratorHelper(this.emissionBursts);try{for(r.s();!(t=r.n()).done;){var n=t.value,s={};Object.assign(s,n),i.push(s)}}catch(t){r.e(t)}finally{r.f()}var a,o,h=[],l=_createForOfIteratorHelper(this.behaviors);try{for(l.s();!(a=l.n()).done;){var c=a.value;h.push(c.clone())}}catch(t){l.e(t)}finally{l.f()}o=this.renderMode===j.Trail?{startLength:this.rendererEmitterSettings.startLength.clone(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===j.StretchedBillBoard?{lengthFactor:this.rendererEmitterSettings.lengthFactor,speedFactor:this.rendererEmitterSettings.speedFactor}:{};var u=new e.Layers;return u.mask=this.layers.mask,new ParticleSystem({autoDestroy:this.autoDestroy,looping:this.looping,duration:this.duration,shape:this.emitterShape.clone(),startLife:this.startLife.clone(),startSpeed:this.startSpeed.clone(),startRotation:this.startRotation.clone(),startSize:this.startSize.clone(),startColor:this.startColor.clone(),emissionOverTime:this.emissionOverTime.clone(),emissionOverDistance:this.emissionOverDistance.clone(),emissionBursts:i,onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry,renderMode:this.renderMode,renderOrder:this.renderOrder,rendererEmitterSettings:o,material:this.rendererSettings.material,startTileIndex:this.startTileIndex,uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.softParticles,softFarFade:this.softFarFade,softNearFade:this.softNearFade,behaviors:h,worldSpace:this.worldSpace,layers:u})}}],[{key:"fromJSON",value:function fromJSON(t,i,r){var n,s,a,o=EmitterFromJSON(t.shape,i);if(t.renderMode===j.Trail){var h=t.rendererEmitterSettings;a={startLength:null!=h.startLength?ValueGeneratorFromJSON(h.startLength):new ConstantValue(30),followLocalOrigin:h.followLocalOrigin}}else t.renderMode===j.Mesh?a={}:t.renderMode===j.StretchedBillBoard?(a=t.rendererEmitterSettings,null!=t.speedFactor&&(a.speedFactor=t.speedFactor)):a={};var l=new e.Layers;t.layers&&(l.mask=t.layers);var c=new ParticleSystem({autoDestroy:t.autoDestroy,looping:t.looping,prewarm:t.prewarm,duration:t.duration,shape:o,startLife:ValueGeneratorFromJSON(t.startLife),startSpeed:ValueGeneratorFromJSON(t.startSpeed),startRotation:GeneratorFromJSON(t.startRotation),startSize:GeneratorFromJSON(t.startSize),startColor:ColorGeneratorFromJSON(t.startColor),emissionOverTime:ValueGeneratorFromJSON(t.emissionOverTime),emissionOverDistance:ValueGeneratorFromJSON(t.emissionOverDistance),emissionBursts:null===(n=t.emissionBursts)||void 0===n?void 0:n.map((function(t){var e,i,r;return{time:t.time,count:"number"==typeof t.count?new ConstantValue(t.count):ValueGeneratorFromJSON(t.count),probability:null!==(e=t.probability)&&void 0!==e?e:1,interval:null!==(i=t.interval)&&void 0!==i?i:.1,cycle:null!==(r=t.cycle)&&void 0!==r?r:1}})),onlyUsedByOther:t.onlyUsedByOther,instancingGeometry:i.geometries[t.instancingGeometry],renderMode:t.renderMode,rendererEmitterSettings:a,renderOrder:t.renderOrder,layers:l,material:t.material?i.materials[t.material]:t.texture?new e.MeshBasicMaterial({map:i.textures[t.texture],transparent:null===(s=t.transparent)||void 0===s||s,blending:t.blending,side:e.DoubleSide}):new e.MeshBasicMaterial({color:16777215,transparent:!0,blending:e.AdditiveBlending,side:e.DoubleSide}),startTileIndex:"number"==typeof t.startTileIndex?new ConstantValue(t.startTileIndex):ValueGeneratorFromJSON(t.startTileIndex),uTileCount:t.uTileCount,vTileCount:t.vTileCount,blendTiles:t.blendTiles,softParticles:t.softParticles,softFarFade:t.softFarFade,softNearFade:t.softNearFade,behaviors:[],worldSpace:t.worldSpace});return c.behaviors=t.behaviors.map((function(t){var e=BehaviorFromJSON(t,c);return e&&"EmitSubParticleSystem"===e.type&&(r[t.subParticleSystem]=e),e})).filter((function(t){return null!==t})),c}}])}(),rt="\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <alphatest_pars_fragment>\n\n#include <tile_pars_fragment>\n#include <soft_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n    \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vColor;\n    \n    #include <logdepthbuf_fragment>\n    \n    #include <tile_fragment>\n    #include <alphatest_fragment>\n\n    outgoingLight = diffuseColor.rgb;\n    \n    #ifdef USE_COLOR_AS_ALPHA\n    gl_FragColor = vec4( outgoingLight, diffuseColor.r );\n    #else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #endif\n    \n    #include <soft_fragment>\n    #include <tonemapping_fragment>\n}\n",nt="\n#define STANDARD\n\n#ifdef PHYSICAL\n#define IOR\n#define USE_SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\nuniform float ior;\n#endif\n\n#ifdef USE_SPECULAR\nuniform float specularIntensity;\nuniform vec3 specularColor;\n\n#ifdef USE_SPECULAR_COLORMAP\nuniform sampler2D specularColorMap;\n#endif\n\n#ifdef USE_SPECULAR_INTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#endif\n\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_DISPERSION\nuniform float dispersion;\n#endif\n\n#ifdef USE_IRIDESCENCE\nuniform float iridescence;\nuniform float iridescenceIOR;\nuniform float iridescenceThicknessMinimum;\nuniform float iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;\nuniform float sheenRoughness;\n\n#ifdef USE_SHEEN_COLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n\n#ifdef USE_SHEEN_ROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\n\n#ifdef USE_ANISOTROPY\nuniform vec2 anisotropyVector;\n\n#ifdef USE_ANISOTROPYMAP\nuniform sampler2D anisotropyMap;\n#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\nvec4 diffuseColor = vec4( diffuse, opacity );\n#include <clipping_planes_fragment>\n\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveRadiance = emissive;\n\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <alphahash_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n\n// accumulation\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n\n// modulation\n#include <aomap_fragment>\n\nvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n#include <transmission_fragment>\n\nvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n#ifdef USE_SHEEN\n\n// Sheen energy compensation approximation calculation can be found at the end of\n// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\noutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\nfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\nvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\noutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\n#endif\n\n#include <opaque_fragment>\n#include <tonemapping_fragment>\n#include <colorspace_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",st="\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n#include <tile_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n    #include <tile_vertex>\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n\n    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n\n#include <color_vertex>\n#include <morphinstance_vertex>\n#include <morphcolor_vertex>\n#include <batching_vertex>\n\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n\n\t// replace defaultnormal_vertex\n\tvec3 transformedNormal = objectNormal;\n    mat3 m = mat3( particleMatrix );\n    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    transformedNormal = m * transformedNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n        #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n        #endif\n    #endif\n\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\n\t// replace include <project_vertex>\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n\tvViewPosition = - mvPosition.xyz;\n\t\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n    vWorldPosition = worldPosition.xyz;\n#endif\n}\n";function getMaterialUVChannelName(t){return 0===t?"uv":"uv".concat(t)}var at=function(t){function ParticleMeshStandardMaterial(t){return _classCallCheck(this,ParticleMeshStandardMaterial),_callSuper(this,ParticleMeshStandardMaterial,[t])}return _inherits(ParticleMeshStandardMaterial,t),_createClass(ParticleMeshStandardMaterial,[{key:"onBeforeCompile",value:function onBeforeCompile(t,e){_superPropGet(ParticleMeshStandardMaterial,"onBeforeCompile",this,3)([t,e]),t.vertexShader=st,t.fragmentShader=nt}}])}(e.MeshStandardMaterial),ot=function(t){function ParticleMeshPhysicsMaterial(t){return _classCallCheck(this,ParticleMeshPhysicsMaterial),_callSuper(this,ParticleMeshPhysicsMaterial,[t])}return _inherits(ParticleMeshPhysicsMaterial,t),_createClass(ParticleMeshPhysicsMaterial,[{key:"onBeforeCompile",value:function onBeforeCompile(t,e){_superPropGet(ParticleMeshPhysicsMaterial,"onBeforeCompile",this,3)([t,e]),t.vertexShader=st,t.fragmentShader=nt}}])}(e.MeshPhysicalMaterial),ht=function(t){function SpriteBatch(t){var e;return _classCallCheck(this,SpriteBatch),_defineProperty(e=_callSuper(this,SpriteBatch,[t]),"offsetBuffer",void 0),_defineProperty(e,"rotationBuffer",void 0),_defineProperty(e,"sizeBuffer",void 0),_defineProperty(e,"colorBuffer",void 0),_defineProperty(e,"uvTileBuffer",void 0),_defineProperty(e,"velocityBuffer",void 0),_defineProperty(e,"vector_",new Vector3),_defineProperty(e,"vector2_",new Vector3),_defineProperty(e,"vector3_",new Vector3),_defineProperty(e,"quaternion_",new Quaternion),_defineProperty(e,"quaternion2_",new Quaternion),_defineProperty(e,"quaternion3_",new Quaternion),_defineProperty(e,"rotationMat_",new Matrix3),_defineProperty(e,"rotationMat2_",new Matrix3),e.maxParticles=1e3,e.setupBuffers(),e.rebuildMaterial(),e}return _inherits(SpriteBatch,t),_createClass(SpriteBatch,[{key:"buildExpandableBuffers",value:function buildExpandableBuffers(){this.offsetBuffer=new e.InstancedBufferAttribute(new Float32Array(3*this.maxParticles),3),this.offsetBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("offset",this.offsetBuffer),this.colorBuffer=new e.InstancedBufferAttribute(new Float32Array(4*this.maxParticles),4),this.colorBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("color",this.colorBuffer),this.settings.renderMode===j.Mesh?(this.rotationBuffer=new e.InstancedBufferAttribute(new Float32Array(4*this.maxParticles),4),this.rotationBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("rotation",this.rotationBuffer)):this.settings.renderMode!==j.BillBoard&&this.settings.renderMode!==j.HorizontalBillBoard&&this.settings.renderMode!==j.VerticalBillBoard&&this.settings.renderMode!==j.StretchedBillBoard||(this.rotationBuffer=new e.InstancedBufferAttribute(new Float32Array(this.maxParticles),1),this.rotationBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("rotation",this.rotationBuffer)),this.sizeBuffer=new e.InstancedBufferAttribute(new Float32Array(3*this.maxParticles),3),this.sizeBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("size",this.sizeBuffer),this.uvTileBuffer=new e.InstancedBufferAttribute(new Float32Array(this.maxParticles),1),this.uvTileBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("uvTile",this.uvTileBuffer),this.settings.renderMode===j.StretchedBillBoard&&(this.velocityBuffer=new e.InstancedBufferAttribute(new Float32Array(4*this.maxParticles),4),this.velocityBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("velocity",this.velocityBuffer))}},{key:"setupBuffers",value:function setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new e.InstancedBufferGeometry,this.geometry.setIndex(this.settings.instancingGeometry.getIndex()),this.settings.instancingGeometry.hasAttribute("normal")&&this.geometry.setAttribute("normal",this.settings.instancingGeometry.getAttribute("normal")),this.geometry.setAttribute("position",this.settings.instancingGeometry.getAttribute("position")),this.settings.instancingGeometry.hasAttribute("uv")&&this.geometry.setAttribute("uv",this.settings.instancingGeometry.getAttribute("uv")),this.buildExpandableBuffers()}},{key:"expandBuffers",value:function expandBuffers(t){for(;t>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}},{key:"rebuildMaterial",value:function rebuildMaterial(){this.layers.mask=this.settings.layers.mask;var t={},i={};"MeshStandardMaterial"!==this.settings.material.type&&"MeshPhysicalMaterial"!==this.settings.material.type&&(t.map=new e.Uniform(this.settings.material.map)),this.settings.material.alphaTest&&(i.USE_ALPHATEST="",t.alphaTest=new e.Uniform(this.settings.material.alphaTest)),i.USE_UV="";var r,n=this.settings.uTileCount,s=this.settings.vTileCount;if((n>1||s>1)&&(i.UV_TILE="",t.tileCount=new e.Uniform(new Vector2(n,s))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(i.USE_COLOR_AS_ALPHA=""),this.settings.material.normalMap&&(i.USE_NORMALMAP="",i.NORMALMAP_UV=getMaterialUVChannelName(this.settings.material.normalMap.channel),t.normalMapTransform=new e.Uniform((new Matrix3).copy(this.settings.material.normalMap.matrix))),this.settings.material.map&&(i.USE_MAP="",this.settings.blendTiles&&(i.TILE_BLEND=""),i.MAP_UV=getMaterialUVChannelName(this.settings.material.map.channel),t.mapTransform=new e.Uniform((new Matrix3).copy(this.settings.material.map.matrix))),i.USE_COLOR_ALPHA="",this.settings.softParticles){i.SOFT_PARTICLES="";var a=this.settings.softNearFade,o=1/(this.settings.softFarFade-this.settings.softNearFade);t.softParams=new e.Uniform(new Vector2(a,o)),t.depthTexture=new e.Uniform(null);var h=t.projParams=new e.Uniform(new Vector4);r=function onBeforeRender(t,e,i){h.value.set(i.near,i.far,0,0)}}var l=!1;if(this.settings.renderMode===j.BillBoard||this.settings.renderMode===j.VerticalBillBoard||this.settings.renderMode===j.HorizontalBillBoard||this.settings.renderMode===j.Mesh){var c,u;this.settings.renderMode===j.Mesh?"MeshStandardMaterial"===this.settings.material.type||"MeshPhysicalMaterial"===this.settings.material.type?(i.USE_COLOR="",c=st,u=nt,l=!0):(c="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n// attribute vec4 color;\n\nvoid main() {\n\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n    \n    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n    \n    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n    #include <tile_vertex>\n    #include <soft_vertex>\n}\n",u=rt):(c="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\n\nvoid main() {\n\t\n    vec2 alignedPosition = position.xy * size.xy;\n    \n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n#ifdef HORIZONTAL\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.x += rotatedPosition.x;\n    mvPosition.z -= rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n#elif defined(VERTICAL)\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.y += rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n    mvPosition.x += rotatedPosition.x;\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    mvPosition.xy += rotatedPosition;\n#endif\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\n\t#include <clipping_planes_vertex>\n\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",u=rt),this.settings.renderMode===j.VerticalBillBoard?i.VERTICAL="":this.settings.renderMode===j.HorizontalBillBoard&&(i.HORIZONTAL="");var d=!1;this.settings.renderMode===j.Mesh&&("MeshStandardMaterial"===this.settings.material.type?(this.material=new at({}),this.material.copy(this.settings.material),this.material.uniforms=t,this.material.defines=i,d=!0):"MeshPhysicalMaterial"===this.settings.material.type&&(this.material=new ot({}),this.material.copy(this.settings.material),this.material.uniforms=t,this.material.defines=i,d=!0)),d||(this.material=new e.ShaderMaterial({uniforms:t,defines:i,vertexShader:c,fragmentShader:u,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest,lights:l}))}else{if(this.settings.renderMode!==j.StretchedBillBoard)throw new Error("render mode unavailable");t.speedFactor=new e.Uniform(1),this.material=new e.ShaderMaterial({uniforms:t,defines:i,vertexShader:"\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\nattribute vec4 velocity;\n\nuniform float speedFactor;\n\nvoid main() {\n    float lengthFactor = velocity.w;\n    float avgSize = (size.x + size.y) * 0.5;\n#ifdef USE_SKEW\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n\n    vec3 scaledPos = vec3(position.xy * size.xy, position.z);\n    float vlength = length(viewVelocity);\n    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;\n    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n    float vlength = length(viewVelocity); \n    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation\n    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation\n#endif\n\tvColor = color;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",fragmentShader:rt,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest})}this.material&&r&&(this.material.onBeforeRender=r)}},{key:"update",value:function update(){var t,e=0,i=0,r=this.getVisibleSystems(),n=_createForOfIteratorHelper(r);try{for(n.s();!(t=n.n()).done;)i+=t.value.particleNum}catch(t){n.e(t)}finally{n.f()}i>this.maxParticles&&this.expandBuffers(i);var s,a=_createForOfIteratorHelper(r);try{for(a.s();!(s=a.n()).done;){var o=s.value;o.emitter.updateMatrixWorld&&(o.emitter.updateWorldMatrix(!0,!1),o.emitter.updateMatrixWorld(!0));var h=o.particles,l=o.particleNum,c=this.quaternion2_,u=this.vector2_,d=this.vector3_;o.emitter.matrixWorld.decompose(u,c,d),this.rotationMat_.setFromMatrix4(o.emitter.matrixWorld);for(var m=0;m<l;m++,e++){var p=h[m];if(this.settings.renderMode===j.Mesh){var f=void 0;if(o.worldSpace)f=p.rotation;else{var y=void 0;y=p.parentMatrix?this.quaternion3_.setFromRotationMatrix(p.parentMatrix):c,(f=this.quaternion_).copy(y).multiply(p.rotation)}this.rotationBuffer.setXYZW(e,f.x,f.y,f.z,f.w)}else this.settings.renderMode!==j.StretchedBillBoard&&this.settings.renderMode!==j.VerticalBillBoard&&this.settings.renderMode!==j.HorizontalBillBoard&&this.settings.renderMode!==j.BillBoard||this.rotationBuffer.setX(e,p.rotation);var v=void 0;if(o.worldSpace?v=p.position:(v=this.vector_,p.parentMatrix?v.copy(p.position).applyMatrix4(p.parentMatrix):v.copy(p.position).applyMatrix4(o.emitter.matrixWorld)),this.offsetBuffer.setXYZ(e,v.x,v.y,v.z),this.colorBuffer.setXYZW(e,p.color.x,p.color.y,p.color.z,p.color.w),o.worldSpace||p.parentMatrix?this.sizeBuffer.setXYZ(e,p.size.x,p.size.y,p.size.z):this.sizeBuffer.setXYZ(e,p.size.x*Math.abs(d.x),p.size.y*Math.abs(d.y),p.size.z*Math.abs(d.z)),this.uvTileBuffer.setX(e,p.uvTile),this.settings.renderMode===j.StretchedBillBoard&&this.velocityBuffer){var g=o.rendererEmitterSettings.speedFactor;0===g&&(g=.001);var S=o.rendererEmitterSettings.lengthFactor,x=void 0;o.worldSpace?x=p.velocity:(x=this.vector_,p.parentMatrix?(this.rotationMat2_.setFromMatrix4(p.parentMatrix),x.copy(p.velocity).applyMatrix3(this.rotationMat2_)):x.copy(p.velocity).applyMatrix3(this.rotationMat_)),this.velocityBuffer.setXYZW(e,x.x*g,x.y*g,x.z*g,S)}}}}catch(t){a.e(t)}finally{a.f()}this.geometry.instanceCount=e,e>0&&(this.offsetBuffer.clearUpdateRanges(),this.offsetBuffer.addUpdateRange(0,3*e),this.offsetBuffer.needsUpdate=!0,this.sizeBuffer.clearUpdateRanges(),this.sizeBuffer.addUpdateRange(0,3*e),this.sizeBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.uvTileBuffer.clearUpdateRanges(),this.uvTileBuffer.addUpdateRange(0,e),this.uvTileBuffer.needsUpdate=!0,this.settings.renderMode===j.StretchedBillBoard&&this.velocityBuffer&&(this.velocityBuffer.clearUpdateRanges(),this.velocityBuffer.addUpdateRange(0,4*e),this.velocityBuffer.needsUpdate=!0),this.settings.renderMode===j.Mesh?(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,4*e),this.rotationBuffer.needsUpdate=!0):this.settings.renderMode!==j.StretchedBillBoard&&this.settings.renderMode!==j.HorizontalBillBoard&&this.settings.renderMode!==j.VerticalBillBoard&&this.settings.renderMode!==j.BillBoard||(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,e),this.rotationBuffer.needsUpdate=!0))}},{key:"dispose",value:function dispose(){this.geometry.dispose()}}])}(Z),lt=function(t){function TrailBatch(t){var e;return _classCallCheck(this,TrailBatch),_defineProperty(e=_callSuper(this,TrailBatch,[t]),"positionBuffer",void 0),_defineProperty(e,"previousBuffer",void 0),_defineProperty(e,"nextBuffer",void 0),_defineProperty(e,"uvBuffer",void 0),_defineProperty(e,"sideBuffer",void 0),_defineProperty(e,"widthBuffer",void 0),_defineProperty(e,"colorBuffer",void 0),_defineProperty(e,"indexBuffer",void 0),_defineProperty(e,"vector_",new Vector3),_defineProperty(e,"vector2_",new Vector3),_defineProperty(e,"vector3_",new Vector3),_defineProperty(e,"quaternion_",new Quaternion),e.maxParticles=1e4,e.setupBuffers(),e.rebuildMaterial(),e}return _inherits(TrailBatch,t),_createClass(TrailBatch,[{key:"setupBuffers",value:function setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new e.BufferGeometry,this.indexBuffer=new e.BufferAttribute(new Uint32Array(6*this.maxParticles),1),this.indexBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setIndex(this.indexBuffer),this.positionBuffer=new e.BufferAttribute(new Float32Array(6*this.maxParticles),3),this.positionBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("position",this.positionBuffer),this.previousBuffer=new e.BufferAttribute(new Float32Array(6*this.maxParticles),3),this.previousBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("previous",this.previousBuffer),this.nextBuffer=new e.BufferAttribute(new Float32Array(6*this.maxParticles),3),this.nextBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("next",this.nextBuffer),this.widthBuffer=new e.BufferAttribute(new Float32Array(2*this.maxParticles),1),this.widthBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("width",this.widthBuffer),this.sideBuffer=new e.BufferAttribute(new Float32Array(2*this.maxParticles),1),this.sideBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("side",this.sideBuffer),this.uvBuffer=new e.BufferAttribute(new Float32Array(4*this.maxParticles),2),this.uvBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("uv",this.uvBuffer),this.colorBuffer=new e.BufferAttribute(new Float32Array(8*this.maxParticles),4),this.colorBuffer.setUsage(e.DynamicDrawUsage),this.geometry.setAttribute("color",this.colorBuffer)}},{key:"expandBuffers",value:function expandBuffers(t){for(;t>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}},{key:"rebuildMaterial",value:function rebuildMaterial(){this.layers.mask=this.settings.layers.mask;var t={lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},resolution:{value:new Vector2(1,1)},sizeAttenuation:{value:1},visibility:{value:1},alphaTest:{value:0}},i={USE_UV:"",USE_COLOR_ALPHA:""};if(this.settings.material.map&&(i.USE_MAP="",i.MAP_UV=getMaterialUVChannelName(this.settings.material.map.channel),t.map=new e.Uniform(this.settings.material.map),t.mapTransform=new e.Uniform((new Matrix3).copy(this.settings.material.map.matrix))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(i.USE_COLOR_AS_ALPHA=""),this.settings.renderMode!==j.Trail)throw new Error("render mode unavailable");this.material=new e.ShaderMaterial({uniforms:t,defines:i,vertexShader:"\n#include <common>\n#include <tile_pars_vertex>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <fog_pars_vertex>\n\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\n\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\n    \nvec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n    \nvoid main() {\n\n    #include <tile_vertex>\n    \n    float aspect = resolution.x / resolution.y;\n\n    vColor = color;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( position, 1.0 );\n    vec4 prevPos = m * vec4( previous, 1.0 );\n    vec4 nextPos = m * vec4( next, 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );\n\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;\n    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n    normal.xy *= .5 * w;\n    normal *= projectionMatrix;\n    if( sizeAttenuation == 0. ) {\n        normal.xy *= finalPosition.w;\n        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n    }\n\n    finalPosition.xy += normal.xy * side;\n\n    gl_Position = finalPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \n\t#include <fog_vertex>\n}",fragmentShader:"\n\n#include <common>\n#include <tile_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform sampler2D alphaMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\n\nvarying vec4 vColor;\n    \nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <logdepthbuf_fragment>\n\n    vec4 diffuseColor = vColor;\n    \n    #ifdef USE_MAP\n    #include <tile_fragment>\n    #ifndef USE_COLOR_AS_ALPHA\n    #endif\n    #endif\n    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;\n    if( diffuseColor.a < alphaTest ) discard;\n    gl_FragColor = diffuseColor;\n\n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n}",transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,side:this.settings.material.side,blending:this.settings.material.blending||e.AdditiveBlending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha})}},{key:"update",value:function update(){var t,e=0,i=0,r=0,n=this.getVisibleSystems(),s=_createForOfIteratorHelper(n);try{for(s.s();!(t=s.n()).done;)for(var a=t.value,o=0;o<a.particleNum;o++)r+=2*a.particles[o].previous.length}catch(t){s.e(t)}finally{s.f()}r>this.maxParticles&&this.expandBuffers(r);var h,l=_createForOfIteratorHelper(n);try{for(l.s();!(h=l.n()).done;){var c=h.value;c.emitter.updateMatrixWorld&&(c.emitter.updateWorldMatrix(!0,!1),c.emitter.updateMatrixWorld(!0));var u=this.quaternion_,d=this.vector2_,m=this.vector3_;c.emitter.matrixWorld.decompose(d,u,m);for(var p=c.particles,f=c.particleNum,y=this.settings.uTileCount,v=this.settings.vTileCount,g=1/y,S=1/v,x=0;x<f;x++){var _=p[x],M=_.uvTile%v,w=Math.floor(_.uvTile/v+.001),O=_.previous.values(),b=O.next(),z=b.value,P=z;b.done||(b=O.next());var E=void 0;E=void 0!==b.value?b.value:P;for(var C=0;C<_.previous.length;C++,e+=2){if(this.positionBuffer.setXYZ(e,P.position.x,P.position.y,P.position.z),this.positionBuffer.setXYZ(e+1,P.position.x,P.position.y,P.position.z),c.worldSpace?(this.positionBuffer.setXYZ(e,P.position.x,P.position.y,P.position.z),this.positionBuffer.setXYZ(e+1,P.position.x,P.position.y,P.position.z)):(_.parentMatrix?this.vector_.copy(P.position).applyMatrix4(_.parentMatrix):this.vector_.copy(P.position).applyMatrix4(c.emitter.matrixWorld),this.positionBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.positionBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),c.worldSpace?(this.previousBuffer.setXYZ(e,z.position.x,z.position.y,z.position.z),this.previousBuffer.setXYZ(e+1,z.position.x,z.position.y,z.position.z)):(_.parentMatrix?this.vector_.copy(z.position).applyMatrix4(_.parentMatrix):this.vector_.copy(z.position).applyMatrix4(c.emitter.matrixWorld),this.previousBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.previousBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),c.worldSpace?(this.nextBuffer.setXYZ(e,E.position.x,E.position.y,E.position.z),this.nextBuffer.setXYZ(e+1,E.position.x,E.position.y,E.position.z)):(_.parentMatrix?this.vector_.copy(E.position).applyMatrix4(_.parentMatrix):this.vector_.copy(E.position).applyMatrix4(c.emitter.matrixWorld),this.nextBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.nextBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),this.sideBuffer.setX(e,1),this.sideBuffer.setX(e+1,-1),c.worldSpace)this.widthBuffer.setX(e,P.size),this.widthBuffer.setX(e+1,P.size);else if(_.parentMatrix)this.widthBuffer.setX(e,P.size),this.widthBuffer.setX(e+1,P.size);else{var A=(Math.abs(m.x)+Math.abs(m.y)+Math.abs(m.z))/3;this.widthBuffer.setX(e,P.size*A),this.widthBuffer.setX(e+1,P.size*A)}this.uvBuffer.setXY(e,(C/_.previous.length+M)*g,(v-w-1)*S),this.uvBuffer.setXY(e+1,(C/_.previous.length+M)*g,(v-w)*S),this.colorBuffer.setXYZW(e,P.color.x,P.color.y,P.color.z,P.color.w),this.colorBuffer.setXYZW(e+1,P.color.x,P.color.y,P.color.z,P.color.w),C+1<_.previous.length&&(this.indexBuffer.setX(3*i,e),this.indexBuffer.setX(3*i+1,e+1),this.indexBuffer.setX(3*i+2,e+2),i++,this.indexBuffer.setX(3*i,e+2),this.indexBuffer.setX(3*i+1,e+1),this.indexBuffer.setX(3*i+2,e+3),i++),z=P,P=E,b.done||void 0!==(b=O.next()).value&&(E=b.value)}}}}catch(t){l.e(t)}finally{l.f()}this.positionBuffer.clearUpdateRanges(),this.positionBuffer.addUpdateRange(0,3*e),this.positionBuffer.needsUpdate=!0,this.previousBuffer.clearUpdateRanges(),this.previousBuffer.addUpdateRange(0,3*e),this.previousBuffer.needsUpdate=!0,this.nextBuffer.clearUpdateRanges(),this.nextBuffer.addUpdateRange(0,3*e),this.nextBuffer.needsUpdate=!0,this.sideBuffer.clearUpdateRanges(),this.sideBuffer.addUpdateRange(0,e),this.sideBuffer.needsUpdate=!0,this.widthBuffer.clearUpdateRanges(),this.widthBuffer.addUpdateRange(0,e),this.widthBuffer.needsUpdate=!0,this.uvBuffer.clearUpdateRanges(),this.uvBuffer.addUpdateRange(0,2*e),this.uvBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.indexBuffer.clearUpdateRanges(),this.indexBuffer.addUpdateRange(0,3*i),this.indexBuffer.needsUpdate=!0,this.geometry.setDrawRange(0,3*i)}},{key:"dispose",value:function dispose(){this.geometry.dispose()}}])}(Z),ct=function(t){function BatchedRenderer(){var t;return _classCallCheck(this,BatchedRenderer),_defineProperty(t=_callSuper(this,BatchedRenderer),"batches",[]),_defineProperty(t,"systemToBatchIndex",new Map),_defineProperty(t,"type","BatchedRenderer"),_defineProperty(t,"depthTexture",null),t}return _inherits(BatchedRenderer,t),_createClass(BatchedRenderer,[{key:"addSystem",value:function addSystem(t){t._renderer=this;for(var e,i=t.getRendererSettings(),r=0;r<this.batches.length;r++)if(BatchedRenderer.equals(this.batches[r].settings,i))return this.batches[r].addSystem(t),void this.systemToBatchIndex.set(t,r);switch(i.renderMode){case j.Trail:e=new lt(i);break;case j.Mesh:case j.BillBoard:case j.VerticalBillBoard:case j.HorizontalBillBoard:case j.StretchedBillBoard:e=new ht(i)}this.depthTexture&&e.applyDepthTexture(this.depthTexture),e.addSystem(t),this.batches.push(e),this.systemToBatchIndex.set(t,this.batches.length-1),this.add(e)}},{key:"deleteSystem",value:function deleteSystem(t){var e=this.systemToBatchIndex.get(t);null!=e&&(this.batches[e].removeSystem(t),this.systemToBatchIndex.delete(t))}},{key:"setDepthTexture",value:function setDepthTexture(t){this.depthTexture=t;var e,i=_createForOfIteratorHelper(this.batches);try{for(i.s();!(e=i.n()).done;)e.value.applyDepthTexture(t)}catch(t){i.e(t)}finally{i.f()}}},{key:"updateSystem",value:function updateSystem(t){this.deleteSystem(t),this.addSystem(t)}},{key:"update",value:function update(t){this.systemToBatchIndex.forEach((function(e,i){i.update(t)}));for(var e=0;e<this.batches.length;e++)this.batches[e].update()}}],[{key:"equals",value:function equals(t,e){return t.material.side===e.material.side&&t.material.blending===e.material.blending&&t.material.blendSrc===e.material.blendSrc&&t.material.blendDst===e.material.blendDst&&t.material.blendEquation===e.material.blendEquation&&t.material.premultipliedAlpha===e.material.premultipliedAlpha&&t.material.transparent===e.material.transparent&&t.material.depthTest===e.material.depthTest&&t.material.type===e.material.type&&t.material.alphaTest===e.material.alphaTest&&t.material.map===e.material.map&&t.renderMode===e.renderMode&&t.blendTiles===e.blendTiles&&t.softParticles===e.softParticles&&t.softFarFade===e.softFarFade&&t.softNearFade===e.softNearFade&&t.uTileCount===e.uTileCount&&t.vTileCount===e.vTileCount&&t.instancingGeometry===e.instancingGeometry&&t.renderOrder===e.renderOrder&&t.layers.mask===e.layers.mask}}])}(e.Object3D),ut=ct,dt=function(t){function QuarksPrefab(){var t;return _classCallCheck(this,QuarksPrefab),_defineProperty(t=_callSuper(this,QuarksPrefab),"type","QuarksPrefab"),_defineProperty(t,"animationData",[]),_defineProperty(t,"isPlaying",!1),_defineProperty(t,"currentTime",-1e-5),_defineProperty(t,"timeScale",1),_defineProperty(t,"duration",0),_defineProperty(t,"_clock",void 0),_defineProperty(t,"_mixers",new Map),_defineProperty(t,"_batchedRenderer",void 0),_defineProperty(t,"_tempAnimationJSON",[]),t._clock=new e.Clock(!0),t}return _inherits(QuarksPrefab,t),_createClass(QuarksPrefab,[{key:"registerBatchedRenderer",value:function registerBatchedRenderer(t){this._batchedRenderer=t}},{key:"getOrCreateMixer",value:function getOrCreateMixer(t){if(!this._mixers.has(t)){var i=new e.AnimationMixer(t);this._mixers.set(t,i)}return this._mixers.get(t)}},{key:"addThreeAnimation",value:function addThreeAnimation(t,i){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:i.duration,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=this.getOrCreateMixer(t),o=a.clipAction(i);s||(o.setLoop(e.LoopOnce,1),o.clampWhenFinished=!0);var h={startTime:r,duration:n,type:"three",loop:s,target:t,clip:i,mixer:a,action:o};return this.animationData.push(h),this.updateDuration(),h}},{key:"addParticleSystemAnimation",value:function addParticleSystemAnimation(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];i<=0&&(i=t.system.duration);var n={startTime:e,duration:i,type:"ps",loop:r,target:t};return this.animationData.push(n),this.pause(),this.updateDuration(),n}},{key:"removeAnimation",value:function removeAnimation(t){this.animationData.splice(t,1),this.updateDuration()}},{key:"play",value:function play(){this.isPlaying||(this.isPlaying=!0)}},{key:"pause",value:function pause(){this.isPlaying&&(this.isPlaying=!1,this.animationData.forEach((function(t){t.target&&("ps"!==t.type||t.target.system.paused?"three"===t.type&&t.action&&t.action.isRunning()&&(t.action.paused=!0):t.target.system.pause())})))}},{key:"stop",value:function stop(){this.pause(),this.currentTime=-1e-5,this.animationData.forEach((function(t){"ps"===t.type&&t.target?t.target.system.stop():"three"===t.type&&t.mixer&&t.action&&t.action.reset()}))}},{key:"update",value:function update(t){var e=this;if(this.isPlaying){var i=void 0!==t?t:this._clock.getDelta();this.currentTime+=i*this.timeScale,this.currentTime>this.duration&&this.stop();var r=new Set;this.animationData.forEach((function(t){var n=t.startTime,s=t.duration,a=t.type;t.loop;var o=t.target,h=t.action,l=t.mixer,c=n+s,u=e.currentTime>=n,d=e.currentTime>c,m=Math.abs(e.currentTime-n)<i;"three"===a&&h&&l?u&&!d?(m?(h.reset(),h.play()):h.paused&&(h.paused=!1,h.play()),e.currentTime,r.add(l)):d&&(h.paused=!0):"ps"===a&&o&&(u&&!d?m&&t.target.system.restart():d&&t.target.system.endEmit())})),r.forEach((function(t){t.update(i)}))}}},{key:"setTime",value:function setTime(t){var e=this,i=this.currentTime;this.currentTime=t,this.animationData.forEach((function(r){var n=r.startTime,s=r.duration,a=r.type,o=r.target,h=r.action,l=r.mixer;if("three"===a&&h&&l){if(h.reset(),t>=n&&t<n+s){var c=t-n;h.time=c,h.play(),l.update(0),h.paused=!e.isPlaying}}else"ps"===a&&o&&(t>=n&&t<n+s?(i<n||i>=n+s)&&o.system.restart():o.system.endEmit())}))}},{key:"getDuration",value:function getDuration(){return this.duration}},{key:"updateDuration",value:function updateDuration(){var t=0;this.animationData.forEach((function(e){var i=e.startTime+e.duration;i>t&&(t=i)})),this.duration=t}},{key:"resolveReferences",value:function resolveReferences(t){var e=this;this._tempAnimationJSON.forEach((function(i){var r,n;t.traverse((function(t){t.uuid===i.targetUUID&&(r=t)})),r&&("three"===i.type&&i.clipUUID?(r.animations&&(n=r.animations.find((function(t){return t.uuid===i.clipUUID}))),n&&e.addThreeAnimation(r,n,i.startTime,i.duration,i.loop)):"ps"===i.type&&e.addParticleSystemAnimation(r,i.startTime,i.duration,i.loop))})),this.updateDuration(),this._tempAnimationJSON=[]}},{key:"toJSON",value:function toJSON(){var t=_superPropGet(QuarksPrefab,"toJSON",this,3)([]);return t.object.animationData=this.animationData.map((function(t){var e;return{startTime:t.startTime,duration:t.duration,type:t.type,targetUUID:t.target.uuid,clipUUID:null===(e=t.clip)||void 0===e?void 0:e.uuid,loop:t.loop}})),t}}],[{key:"fromJSON",value:function fromJSON(t){var e=new QuarksPrefab;return t.animationData&&(e._tempAnimationJSON=t.animationData),e}}])}(e.Group),mt=function(t){function QuarksLoader(t){return _classCallCheck(this,QuarksLoader),_callSuper(this,QuarksLoader,[t])}return _inherits(QuarksLoader,t),_createClass(QuarksLoader,[{key:"linkReference",value:function linkReference(t){var e={};t.traverse((function(t){e[t.uuid]=t})),t.traverse((function(t){if("ParticleEmitter"===t.type){var i=t.system;i.emitterShape;for(var r=0;r<i.behaviors.length;r++)i.behaviors[r]instanceof EmitSubParticleSystem&&(i.behaviors[r].subParticleSystem=e[i.behaviors[r].subParticleSystem])}}))}},{key:"parse",value:function parse(t,e){var i=_superPropGet(QuarksLoader,"parse",this,3)([t,e]);return this.linkReference(i),i}},{key:"parseObject",value:function parseObject(t,i,r,n,s){var a,o,h;function getGeometry(t){return void 0===i[t]&&console.warn("THREE.ObjectLoader: Undefined geometry",t),i[t]}function getMaterial(t){if(void 0!==t){if(Array.isArray(t)){for(var e=[],i=0,n=t.length;i<n;i++){var s=t[i];void 0===r[s]&&console.warn("THREE.ObjectLoader: Undefined material",s),e.push(r[s])}return e}return void 0===r[t]&&console.warn("THREE.ObjectLoader: Undefined material",t),r[t]}}function getTexture(t){return void 0===n[t]&&console.warn("THREE.ObjectLoader: Undefined texture",t),n[t]}var l={textures:n,geometries:i,materials:r};switch(t.type){case"QuarksPrefab":a=dt.fromJSON(t);break;case"ParticleEmitter":a=it.fromJSON(t.ps,l,{}).emitter;break;case"Scene":a=new e.Scene,void 0!==t.background&&(Number.isInteger(t.background)?a.background=new e.Color(t.background):a.background=getTexture(t.background)),void 0!==t.environment&&(a.environment=getTexture(t.environment)),void 0!==t.fog&&("Fog"===t.fog.type?a.fog=new e.Fog(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(a.fog=new e.FogExp2(t.fog.color,t.fog.density)),""!==t.fog.name&&(a.fog.name=t.fog.name)),void 0!==t.backgroundBlurriness&&(a.backgroundBlurriness=t.backgroundBlurriness),void 0!==t.backgroundIntensity&&(a.backgroundIntensity=t.backgroundIntensity),void 0!==t.backgroundRotation&&a.backgroundRotation.fromArray(t.backgroundRotation),void 0!==t.environmentIntensity&&(a.environmentIntensity=t.environmentIntensity),void 0!==t.environmentRotation&&a.environmentRotation.fromArray(t.environmentRotation);break;case"PerspectiveCamera":a=new e.PerspectiveCamera(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(a.focus=t.focus),void 0!==t.zoom&&(a.zoom=t.zoom),void 0!==t.filmGauge&&(a.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(a.filmOffset=t.filmOffset),void 0!==t.view&&(a.view=Object.assign({},t.view));break;case"OrthographicCamera":a=new e.OrthographicCamera(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(a.zoom=t.zoom),void 0!==t.view&&(a.view=Object.assign({},t.view));break;case"AmbientLight":a=new e.AmbientLight(t.color,t.intensity);break;case"DirectionalLight":a=new e.DirectionalLight(t.color,t.intensity);break;case"PointLight":a=new e.PointLight(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":a=new e.RectAreaLight(t.color,t.intensity,t.width,t.height);break;case"SpotLight":a=new e.SpotLight(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":a=new e.HemisphereLight(t.color,t.groundColor,t.intensity);break;case"LightProbe":a=new e.LightProbe,void 0!==t.sh&&(a.sh=(new e.SphericalHarmonics3).fromArray(t.sh));break;case"SkinnedMesh":o=getGeometry(t.geometry),h=getMaterial(t.material),a=new e.SkinnedMesh(o,h),void 0!==t.bindMode&&(a.bindMode=t.bindMode),void 0!==t.bindMatrix&&a.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(a.skeleton=t.skeleton);break;case"Mesh":o=getGeometry(t.geometry),h=getMaterial(t.material),a=new e.Mesh(o,h);break;case"InstancedMesh":o=getGeometry(t.geometry),h=getMaterial(t.material);var c=t.count,u=t.instanceMatrix,d=t.instanceColor;(a=new e.InstancedMesh(o,h,c)).instanceMatrix=new e.InstancedBufferAttribute(new Float32Array(u.array),16),void 0!==d&&(a.instanceColor=new e.InstancedBufferAttribute(new Float32Array(d.array),d.itemSize));break;case"BatchedMesh":o=getGeometry(t.geometry),h=getMaterial(t.material),(a=new e.BatchedMesh(t.maxGeometryCount,t.maxVertexCount,t.maxIndexCount,h)).geometry=o,a.perObjectFrustumCulled=t.perObjectFrustumCulled,a.sortObjects=t.sortObjects,a._drawRanges=t.drawRanges,a._reservedRanges=t.reservedRanges,a._visibility=t.visibility,a._active=t.active,a._bounds=t.bounds.map((function(t){var i=new e.Box3;i.min.fromArray(t.boxMin),i.max.fromArray(t.boxMax);var r=new e.Sphere;return r.radius=t.sphereRadius,r.center.fromArray(t.sphereCenter),{boxInitialized:t.boxInitialized,box:i,sphereInitialized:t.sphereInitialized,sphere:r}})),a._maxGeometryCount=t.maxGeometryCount,a._maxVertexCount=t.maxVertexCount,a._maxIndexCount=t.maxIndexCount,a._geometryInitialized=t.geometryInitialized,a._geometryCount=t.geometryCount,a._matricesTexture=getTexture(t.matricesTexture.uuid);break;case"LOD":a=new e.LOD;break;case"Line":a=new e.Line(getGeometry(t.geometry),getMaterial(t.material));break;case"LineLoop":a=new e.LineLoop(getGeometry(t.geometry),getMaterial(t.material));break;case"LineSegments":a=new e.LineSegments(getGeometry(t.geometry),getMaterial(t.material));break;case"PointCloud":case"Points":a=new e.Points(getGeometry(t.geometry),getMaterial(t.material));break;case"Sprite":a=new e.Sprite(getMaterial(t.material));break;case"Group":a=new e.Group;break;case"Bone":a=new e.Bone;break;default:a=new e.Object3D}if(a.uuid=t.uuid,void 0!==t.name&&(a.name=t.name),void 0!==t.matrix?(a.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(a.matrixAutoUpdate=t.matrixAutoUpdate),a.matrixAutoUpdate&&(a.matrix.decompose(a.position,a.quaternion,a.scale),isNaN(a.quaternion.x)&&a.quaternion.set(0,0,0,1))):(void 0!==t.position&&a.position.fromArray(t.position),void 0!==t.rotation&&a.rotation.fromArray(t.rotation),void 0!==t.quaternion&&a.quaternion.fromArray(t.quaternion),void 0!==t.scale&&a.scale.fromArray(t.scale)),void 0!==t.up&&a.up.fromArray(t.up),void 0!==t.castShadow&&(a.castShadow=t.castShadow),void 0!==t.receiveShadow&&(a.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(a.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(a.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(a.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&a.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(a.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(a.visible=t.visible),void 0!==t.frustumCulled&&(a.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(a.renderOrder=t.renderOrder),void 0!==t.userData&&(a.userData=t.userData),void 0!==t.layers&&(a.layers.mask=t.layers),void 0!==t.children)for(var m=t.children,p=0;p<m.length;p++)a.add(this.parseObject(m[p],i,r,n,s));if(void 0!==t.animations)for(var f=t.animations,y=0;y<f.length;y++){var v=f[y];a.animations.push(s[v])}if("LOD"===t.type){void 0!==t.autoUpdate&&(a.autoUpdate=t.autoUpdate);for(var g=t.levels,S=0;S<g.length;S++){var x=g[S],_=a.getObjectByProperty("uuid",x.object);void 0!==_&&a.addLevel(_,x.distance)}}else"QuarksPrefab"===t.type&&a.resolveReferences(a);return a}}])}(e.ObjectLoader),pt=function(){function QuarksUtil(){_classCallCheck(this,QuarksUtil)}return _createClass(QuarksUtil,null,[{key:"runOnAllParticleEmitters",value:function runOnAllParticleEmitters(t,e){t.traverse((function(t){"ParticleEmitter"===t.type&&e(t)})),"ParticleEmitter"===t.type&&e(t)}},{key:"addToBatchRenderer",value:function addToBatchRenderer(t,e){QuarksUtil.runOnAllParticleEmitters(t,(function(t){e.addSystem(t.system)}))}},{key:"play",value:function play(t){QuarksUtil.runOnAllParticleEmitters(t,(function(t){t.system.play()}))}},{key:"stop",value:function stop(t){QuarksUtil.runOnAllParticleEmitters(t,(function(t){t.system.stop()}))}},{key:"setAutoDestroy",value:function setAutoDestroy(t,e){QuarksUtil.runOnAllParticleEmitters(t,(function(t){t.system.autoDestroy=e}))}},{key:"endEmit",value:function endEmit(t){QuarksUtil.runOnAllParticleEmitters(t,(function(t){t.system.endEmit()}))}},{key:"restart",value:function restart(t){QuarksUtil.runOnAllParticleEmitters(t,(function(t){t.system.restart()}))}},{key:"pause",value:function pause(t){QuarksUtil.runOnAllParticleEmitters(t,(function(t){t.system.pause()}))}}])}();registerShaderChunks(),loadPlugin(r),console.log("%c Particle system powered by three.quarks. https://quarks.art/","font-size: 14px; font-weight: bold;"),t.ApplyCollision=ApplyCollision,t.ApplyForce=ApplyForce,t.ApplySequences=ApplySequences,t.AxisAngleGenerator=AxisAngleGenerator,t.BatchedParticleRenderer=ut,t.BatchedRenderer=ct,t.BehaviorFromJSON=BehaviorFromJSON,t.BehaviorTypes=Q,t.Bezier=Bezier,t.ChangeEmitDirection=ChangeEmitDirection,t.CircleEmitter=CircleEmitter,t.ColorBySpeed=ColorBySpeed,t.ColorGeneratorFromJSON=ColorGeneratorFromJSON,t.ColorOverLife=ColorOverLife,t.ColorRange=ColorRange,t.ConeEmitter=ConeEmitter,t.ConstantColor=ConstantColor,t.ConstantValue=ConstantValue,t.DEG2RAD=o,t.DonutEmitter=DonutEmitter,t.EmitSubParticleSystem=EmitSubParticleSystem,t.EmitterFromJSON=EmitterFromJSON,t.EmitterShapes=T,t.Euler=Euler,t.EulerGenerator=EulerGenerator,t.ForceOverLife=ForceOverLife,t.FrameOverLife=FrameOverLife,t.GeneratorFromJSON=GeneratorFromJSON,t.Gradient=Gradient,t.GravityForce=GravityForce,t.GridEmitter=GridEmitter,t.HemisphereEmitter=HemisphereEmitter,t.IntervalValue=IntervalValue,t.LimitSpeedOverLife=LimitSpeedOverLife,t.MathUtils=l,t.Matrix3=Matrix3,t.Matrix4=Matrix4,t.MeshSurfaceEmitter=i,t.MeshSurfaceEmitterPlugin=r,t.NodeParticle=class NodeParticle{constructor(){this.position=new Vector3,this.velocity=new Vector3,this.age=0,this.life=1,this.size=new Vector3,this.rotation=0,this.color=new Vector4(1,1,1,1),this.uvTile=0,this.memory=[]}get died(){return this.age>=this.life}reset(){this.memory.length=0,this.position.set(0,0,0),this.velocity.set(0,0,0),this.age=0,this.life=1,this.size.set(1,1,1),this.rotation=0,this.color.set(1,1,1,1),this.uvTile=0}},t.Noise=Noise,t.OrbitOverLife=OrbitOverLife,t.ParticleEmitter=Y,t.ParticleMeshPhysicsMaterial=ot,t.ParticleMeshStandardMaterial=at,t.ParticleSystem=it,t.PiecewiseBezier=PiecewiseBezier,t.PiecewiseFunction=PiecewiseFunction,t.Plugins=H,t.PointEmitter=PointEmitter,t.QuarksLoader=mt,t.QuarksPrefab=dt,t.QuarksUtil=pt,t.Quaternion=Quaternion,t.RAD2DEG=h,t.RandomColor=RandomColor,t.RandomColorBetweenGradient=RandomColorBetweenGradient,t.RandomQuatGenerator=RandomQuatGenerator,t.RecordState=RecordState,t.RectangleEmitter=RectangleEmitter,t.RenderMode=j,t.Rotation3DOverLife=Rotation3DOverLife,t.RotationBySpeed=RotationBySpeed,t.RotationGeneratorFromJSON=RotationGeneratorFromJSON,t.RotationOverLife=RotationOverLife,t.SequencerFromJSON=SequencerFromJSON,t.SizeBySpeed=SizeBySpeed,t.SizeOverLife=SizeOverLife,t.SpeedOverLife=SpeedOverLife,t.SphereEmitter=SphereEmitter,t.SpriteBatch=ht,t.SpriteParticle=SpriteParticle,t.TextureSequencer=TextureSequencer,t.TrailBatch=lt,t.TrailParticle=TrailParticle,t.TurbulenceField=TurbulenceField,t.VFXBatch=Z,t.ValueGeneratorFromJSON=ValueGeneratorFromJSON,t.Vector2=Vector2,t.Vector3=Vector3,t.Vector3Function=Vector3Function,t.Vector3GeneratorFromJSON=Vector3GeneratorFromJSON,t.Vector4=Vector4,t.WebGLCoordinateSystem=d,t.WebGPUCoordinateSystem=m,t.WidthOverLength=WidthOverLength,t.ceilPowerOfTwo=ceilPowerOfTwo,t.clamp=clamp,t.damp=damp,t.degToRad=degToRad,t.denormalize=denormalize,t.euclideanModulo=euclideanModulo,t.floorPowerOfTwo=floorPowerOfTwo,t.generateUUID=generateUUID,t.getPhysicsResolver=getPhysicsResolver,t.getValueFromEmitterMode=getValueFromEmitterMode,t.inverseLerp=inverseLerp,t.isPowerOfTwo=isPowerOfTwo,t.lerp=lerp,t.loadPlugin=loadPlugin,t.mapLinear=mapLinear,t.normalize=normalize,t.pingpong=pingpong,t.radToDeg=radToDeg,t.randFloat=randFloat,t.randFloatSpread=randFloatSpread,t.randInt=randInt,t.registerShaderChunks=registerShaderChunks,t.seededRandom=seededRandom,t.setPhysicsResolver=function setPhysicsResolver(t){X=t},t.setQuaternionFromProperEuler=setQuaternionFromProperEuler,t.smootherstep=smootherstep,t.smoothstep=smoothstep,t.unloadPlugin=function unloadPlugin(t){const e=H.find((e=>e.id===t));if(e){for(const t of e.emitterShapes)T[t.type]&&delete T[t.type];for(const t of e.behaviors)Q[t.type]&&delete Q[t.type]}}},"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e(((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE.QUARKS={}),t.THREE);
